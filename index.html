<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lvcheng1229.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lvcheng1229.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lvcheng1229.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/08/02/cerrtb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/02/cerrtb/" class="post-title-link" itemprop="url">CryEngine Baking:Real Time RayTracing Baker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-08-02 23:32:58 / Modified: 23:34:46" itemprop="dateCreated datePublished" datetime="2023-08-02T23:32:58+08:00">2023-08-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/08/01/cerhivkrt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/01/cerhivkrt/" class="post-title-link" itemprop="url">CryEngine RHI:Vulkan RayTracing</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-08-01 00:08:24 / Modified: 00:08:40" itemprop="dateCreated datePublished" datetime="2023-08-01T00:08:24+08:00">2023-08-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>CryEngine RHI:Vulkan RayTracing</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/08/01/cerhivk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/01/cerhivk/" class="post-title-link" itemprop="url">CryEngine RHI:Vulkan RHI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-08-01 00:07:29 / Modified: 00:08:06" itemprop="dateCreated datePublished" datetime="2023-08-01T00:07:29+08:00">2023-08-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>CryEngine RHI:Vulkan RHI</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/08/01/cesvsm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/01/cesvsm/" class="post-title-link" itemprop="url">Implement virtual shadow map in CryEngine</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-01 00:06:36" itemprop="dateCreated datePublished" datetime="2023-08-01T00:06:36+08:00">2023-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-06 21:11:14" itemprop="dateModified" datetime="2023-10-06T21:11:14+08:00">2023-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Real-time shadow is an essential field of game development. Without real-time shadow, movable objects will appear floating on the ground and out of tune with the surrounding environment, which decreases game reality. The most used real-time shadow technique is shadow mapping. This technique causes two artifacts: shadow acne and aliasing. The reason behind these artifacts is that many pixels on the screen correspond to one texel on the shadow map. </p>
<p>Ideally, we can solve these problems by allocating an infinite shadow map texture. However, we can’t do this, since video memory is limited. For real-time shadow rendering, most games use CSM (cascade shadow map) to achieve a balance between shadow map quality and game performance. The key idea of CSM is to render a high-quality shadow map for the scene closer to the camera and decrease the shadow quality for further objects.</p>
<p>Virtual shadow map is a possible solution to solving these problems. The main points of Virtual-SM are:1. Only render shadow casters whose shadow can be seen by the camera. 2. Assume the video memory and shadow map texture is large enough (like virtual memory). 3. Manage the scene’s objects and dispatch draw commands on the GPU.</p>
<h1 id="Related-techniques-used-in-Virtual-SM"><a href="#Related-techniques-used-in-Virtual-SM" class="headerlink" title="Related techniques used in Virtual-SM"></a>Related techniques used in Virtual-SM</h1><p>Before discussing Virtual-SM, we will introduce some related techniques: virtual texture and GPU-driven rendering, since Virtual-SM’s idea is similar to the above techniques.</p>
<h2 id="Virtual-Texture"><a href="#Virtual-Texture" class="headerlink" title="Virtual Texture"></a>Virtual Texture</h2><p>The virtual texture is proposed based on a technique called mega texture. Like virtual memory in OS, virtual texture assumes the texture resolution is large enough and does not require the entire texture to be loaded. Instead, we only need to load the part of the texture that is actually used in the current view.</p>
<p>Virtual texture has many variations depending on the situation: streaming virtual texture (SVT), run-time virtual texture (RVT), and its improved version adaptive virtual texture (AVT). The ideas behind SVT&#x2F;RVT&#x2F;AVT are also contained in the Virtual-SM.</p>
<h3 id="Streaming-Virtual-Texture"><a href="#Streaming-Virtual-Texture" class="headerlink" title="Streaming Virtual Texture"></a>Streaming Virtual Texture</h3><p>Streaming virtual texture has four parts:</p>
<ol>
<li>Split the virtual texture into NxN tiles or pages.</li>
<li>Collect the tile and the mipmap of the texture required in the current view. This step can be executed in a separate pass or combined with the PreZ &#x2F; GBuffer Pass.</li>
<li>Feedback and analyze the results and load the texture tiles used.</li>
<li>Construct and update the indirect texture, which stores the coordinates mapping from virtual texture to physical texture.</li>
</ol>
<p>Compared to mipmap texture streaming, SVT has the following advantages:</p>
<ol>
<li>Save video memory (we only load the texture tiles required).</li>
<li>Finer granularity (the minimum load unit is texture tile rather than texture mip).</li>
<li>More accurately (mip texture streaming is computed on CPU and will get wrong results for complex texture types, such as Atlas. SVT is computed on the GPU based on the ddx&#x2F;ddy operation).</li>
</ol>
<h3 id="Runtime-Virtual-Texture"><a href="#Runtime-Virtual-Texture" class="headerlink" title="Runtime Virtual Texture"></a>Runtime Virtual Texture</h3><p>The texture content of SVT is loaded from the disk, that is, generated offline. And RVT generates texture content at runtime. It is most used in terrain rendering. The key idea of RVT in terrain rendering is caching the texture blend result into a runtime virtual texture. This has several advantages compared to the SVT and traditional splat map method:</p>
<ol>
<li>The texture size is too large to store on the disk if we use SVT to blend the terrain texture offline</li>
<li>We need to sample many times for terrain textures (normal &#x2F; base color&#x2F;splat map) for the traditional splat map method. There are only four channels in a splat map, so we can only record four terrain weights, which limits the art effect.</li>
<li>RVT has better performance than the splat map method, and the texture size stored on disk is smaller than SVT. In other words, RVT is a compromise solution to SVT and splat map.</li>
</ol>
<h3 id="Adaptive-Virtual-Texture"><a href="#Adaptive-Virtual-Texture" class="headerlink" title="Adaptive Virtual Texture"></a>Adaptive Virtual Texture</h3><p>Adaptive virtual texture is an improved version based on the RVT. We will get a large indirect table if the terrain is wide enough. AVT solves this problem by allocating different VT sizes depending on camera distance.</p>
<h2 id="GPU-Driven-Rendering"><a href="#GPU-Driven-Rendering" class="headerlink" title="GPU-Driven Rendering"></a>GPU-Driven Rendering</h2><p>In virtual shadow map, each shadow map tile corresponds to a frustum. This means that Virtual-SM will perform culling many times, which is unaffordable for the CPU. GPU-driven rendering can solve these problems by moving culling and submitting tasks from CPU to GPU. Let’s introduce the basic GPU-driven pipeline first. </p>
<p>GPU-driven rendering pipeline has three parts: preparing GPU data, culling on GPU, and work submission.</p>
<h3 id="Prepare-GPU-data"><a href="#Prepare-GPU-data" class="headerlink" title="Prepare GPU data"></a>Prepare GPU data</h3><ol>
<li>Before submitting data to the GPU, we can perform a coarse quad tree culling on the CPU, which reduces the data uploaded to the GPU.</li>
<li>Prepare the data that will be updated. This includes 1. instance&#x2F;primitive data (transform&#x2F;lod factor&#x2F;bounding box), 2. Light map data etc.</li>
<li>Batch draw calls and update the GPU data required in the next step</li>
</ol>
<h3 id="Culling-on-GPU"><a href="#Culling-on-GPU" class="headerlink" title="Culling on GPU"></a>Culling on GPU</h3><p>Culling on GPU, contains the following steps:</p>
<ol>
<li>Instance culling, perform frustum culling and HIZ culling on GPU. And generate the cluster chunk for those instances passing culling.</li>
<li>Perform the frustum and occlusion culling for each cluster based on the cluster’s transform and bound. And perform back-face culling based on cluster orientation precomputed offline.</li>
<li>Index buffer compaction, culling the index unused.</li>
</ol>
<h3 id="Work-Submission"><a href="#Work-Submission" class="headerlink" title="Work Submission"></a>Work Submission</h3><p>Generate commands buffer and use indirect draw to submit the work</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/07/30/cepptb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/30/cepptb/" class="post-title-link" itemprop="url">Implement tiled-Based indirect bloom in CryEngine</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-30 23:08:25" itemprop="dateCreated datePublished" datetime="2023-07-30T23:08:25+08:00">2023-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-05 22:51:05" itemprop="dateModified" datetime="2023-10-05T22:51:05+08:00">2023-10-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>The complexity of postprocess effects varies depending on the screen tile they are applied to. For example, we can only take one sample(disable blur) for pixels whose velocity is relatively low using branching. However, dynamic branching on the GPU is costly since we cannot ensure that multiple threads don’t cause divergence.</p>
<p>The probability of divergence will be significantly reduced if different shaders can be executed on different screen tiles. Therefore, the problem is how to dispatch different shaders on various tiles. </p>
<p>Indirect-Compute Shader is an answer: In the first step, dispatch a compute shader to classify the tiles and determine the tile count and index for each shader complexity level. Then, dispatch a variety of indirect-compute shaders for each tile with the arguments generated in the last step.The result is that each tile performs a specific version of the shader and eliminates divergence.</p>
<p>This article will take the bloom pass as an example of implementing the tile-based post process.</p>
<p>The bloom algorithm is based on the implementation of CryEngine in this demo. So, we are going to discuss the implementation of CryEngine first. There are three parts to CryEngine’s bloom algorithm. The first part is downsampling. CryEngine takes two passes to downsample the render target. The output of the downsample is a quarter-resolution render target relative to the original RT. Then, CryEngine performs a Gaussian blur with a quarter-resolution render target. In this step, CE takes four passes to blur the source texture: two for vertical and two for horizontal. Each pass samples the texture 16 times, so the total number of samples is 64 * Resolution! Finally, CE performs a lerp between scene color and bloom results as the result in the tone mapping pass.</p>
<p>What we are going to do is optimize its sample count. Here is the flow graph of tiled-based bloom algorithm:</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/flowinfo2.jpg"></p>
<p><strong>Step1.Mask screen tiles contain pixels whose luminance exceeds the threshold.</strong></p>
<p>Each tile corresponds to a dispatch group with 8x8 threads and contains 8x8 pixels. We use a group shared unit array to record group luminance info. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupshared uint MaskInfo[GROUP_SIZE_X*GROUP_SIZE_Y*<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Luminance &gt; BloomThreshlod)</span><br><span class="line">&#123;</span><br><span class="line">	Result.rgb = BloomOUT.rgb;</span><br><span class="line">	MaskInfo[GroupThreadID.y * GROUP_SIZE_X + GroupThreadID.x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer2.jpg"></p>
<p>Then, perform parallel reduction within each thread block to determine if this tile contains at least one pixel that exceeds the threshold. As a result, we will get a mask buffer with the size of one eighth of the input bloom texture.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GroupMemoryBarrierWithGroupSync</span>();</span><br><span class="line"></span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span> (uint SetpIndex = <span class="number">1</span>; SetpIndex &lt; <span class="number">4</span>; SetpIndex++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> uint TileSize = <span class="built_in">uint</span>(GROUP_TILE_SIZE) &gt;&gt; SetpIndex;</span><br><span class="line">	<span class="type">const</span> uint ReduceBankSize = TileSize * TileSize;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (GroupThreadIndex &lt; ReduceBankSize)</span><br><span class="line">	&#123;</span><br><span class="line">		uint RawMask[<span class="number">4</span>];</span><br><span class="line">		[unroll]</span><br><span class="line">		<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			uint LDSIndex = GroupThreadIndex + i * ReduceBankSize;</span><br><span class="line">			RawMask[i] = MaskInfo[LDSIndex];</span><br><span class="line">		&#125;</span><br><span class="line">		uint MaskCombine = RawMask[<span class="number">0</span>] || RawMask[<span class="number">1</span>] || RawMask[<span class="number">2</span>] || RawMask[<span class="number">3</span>];</span><br><span class="line">		MaskInfo[GroupThreadIndex] = MaskCombine;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GroupThreadIndex == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BloomMaskOutUAV[GroupID.y * bloomCB.BufferSize.x + GroupID.x] = MaskInfo[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step2.Record the tile index and calculate the number of tiles that will perform the Gaussian blur.</strong></p>
<p>The results will be used as indirect arguments in the next step.</p>
<p>The kernel size of the first two Gaussian blur passes is 7 and each member of the mask buffer represents 8x8 pixels. Therefore, the tile being masked will affect the 3x3 tiles around it. </p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer3.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint CIndex = DispatchThreadID.y * MaskBufferSize.x + DispatchThreadID.x;</span><br><span class="line">uint LCIndex = CIndex - <span class="number">1</span>;</span><br><span class="line">uint RCIndex = CIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">uint TIndex = (DispatchThreadID.y - <span class="number">1</span>) * MaskBufferSize.x + DispatchThreadID.x;</span><br><span class="line">uint LTIndex = TIndex - <span class="number">1</span>;</span><br><span class="line">uint RTIndex = TIndex + <span class="number">1</span>;</span><br><span class="line">uint BIndex = (DispatchThreadID.y +<span class="number">1</span> ) * MaskBufferSize.x + DispatchThreadID.x;</span><br><span class="line">uint LBIndex = BIndex - <span class="number">1</span>;</span><br><span class="line">uint RBIndex = BIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">uint CValue = IndexGen_MaskBuffer[CIndex].x;</span><br><span class="line">uint LCValue = IndexGen_MaskBuffer[LCIndex].x;</span><br><span class="line">uint RCValue = IndexGen_MaskBuffer[RCIndex].x;</span><br><span class="line">uint TValue = IndexGen_MaskBuffer[TIndex].x;</span><br><span class="line">uint LTValue = IndexGen_MaskBuffer[LTIndex].x;</span><br><span class="line">uint RTValue = IndexGen_MaskBuffer[RTIndex].x;</span><br><span class="line">uint BValue = IndexGen_MaskBuffer[BIndex].x;</span><br><span class="line">uint LBValue = IndexGen_MaskBuffer[LBIndex].x;</span><br><span class="line">uint RBValue = IndexGen_MaskBuffer[RBIndex].x;</span><br><span class="line"></span><br><span class="line">uint CMaskValue = CValue || LCValue || RCValue;</span><br><span class="line">uint TMaskValue = TValue || LTValue || RTValue;</span><br><span class="line">uint BMaskValue = BValue || LBValue || RBValue;</span><br><span class="line">uint MaskValue = CMaskValue || TMaskValue || BMaskValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MaskValue)</span><br><span class="line">&#123;</span><br><span class="line">	uint PreCountOut;</span><br><span class="line">	IndexGen_DispatchIndirectCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>, <span class="built_in">uint</span>(<span class="number">1</span>), PreCountOut);</span><br><span class="line">	<span class="type">const</span> uint TileIndex = (DispatchThreadID.x &amp; <span class="number">0xFFFF</span>) | ((DispatchThreadID.y &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">	IndexGen_TileIndexUAV[PreCountOut] = TileIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We use the InterlockedAdd function to count the tile number and store the result in an RWByteAddressBuffer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RWByteAddressBuffer 			IndexGen_DispatchIndirectCount	: <span class="built_in">register</span>(u1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">all</span>(DispatchThreadID == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	IndexGen_DispatchIndirectCount.<span class="built_in">Store3</span>(<span class="number">0</span>,<span class="built_in">uint3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MaskValue)</span><br><span class="line">&#123;</span><br><span class="line">	uint PreCountOut;</span><br><span class="line">	IndexGen_DispatchIndirectCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>, <span class="built_in">uint</span>(<span class="number">1</span>), PreCountOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Taking the above figure as an example, the value of the DispatchIndirectCount buffer is (12,1,1) and the value of the tile index buffer is (4,2), (4,3), (4,4), ……, (5,2), (5,3), (5,4),……</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer4.jpg"></p>
<p>The red blocks are the tiles that performed Gaussian blur in the first two passes, and their size is 8x8 pixels per tile. Next, we will generate the mask buffer for the last two Gaussian blur passes based on the above results. In the last two blur passes, the tile size is 16x16 since the kernel size in the last two blur passes is 15.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span>(MaskValue)</span><br><span class="line">		&#123;</span><br><span class="line">			uint PreCountOut;</span><br><span class="line">			IndexGen_DispatchIndirectCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>, <span class="built_in">uint</span>(<span class="number">1</span>), PreCountOut);</span><br><span class="line">			<span class="type">const</span> uint TileIndex = (DispatchThreadID.x &amp; <span class="number">0xFFFF</span>) | ((DispatchThreadID.y &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">			IndexGen_TileIndexUAV[PreCountOut] = TileIndex;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> %_RT_SAMPLE0</span></span><br><span class="line">			IndexGen_TileMask[GroupThreadID.y * GROUP_SIZE_X + GroupThreadID.x] = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> %_RT_SAMPLE0</span></span><br><span class="line">		<span class="keyword">if</span>(GroupThreadIndex % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			uint RawMask[<span class="number">4</span>];</span><br><span class="line">			[unroll]</span><br><span class="line">			<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				uint LDSIndex = GroupThreadIndex + i;</span><br><span class="line">				RawMask[i] = IndexGen_TileMask[LDSIndex];</span><br><span class="line">			&#125;</span><br><span class="line">			uint MaskCombine = RawMask[<span class="number">0</span>] || RawMask[<span class="number">1</span>] || RawMask[<span class="number">2</span>] || RawMask[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">			IndexGen_MaskOutputUAV[(DispatchThreadID.y / <span class="number">2</span>) * (MaskBufferSize.x / <span class="number">2</span>) + DispatchThreadID.x / <span class="number">2</span>] = MaskCombine;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Repeat step 2. We will get all the parameters needed in the Gaussian blur pass.</p>
<p><strong>Step3. Dispatch indirect compute shader and perform Gaussian blur.</strong></p>
<p>The dispatch size is (12,1,1) in this example.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetDispatchIndirectArgs</span>(&amp;m_dispatchIndirectCount[IndexPass], <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Get the index for those tiles performing Gaussian blur indexed by GroupID from the tile index buffer and calculate the global UV coordinates based on the tile index.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint TileIndex = BloomFinal_TileInfoUAV.<span class="built_in">Load</span>(GroupID.x).x;</span><br><span class="line">uint2 TileIndexXY = <span class="built_in">uint2</span>(TileIndex &amp; <span class="number">0xFFFF</span>,(TileIndex &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">uint2 UVCoord = TileIndexXY * <span class="built_in">uint2</span>(GROUP_SIZE_X * <span class="number">2</span>,GROUP_SIZE_Y * <span class="number">2</span>) + <span class="built_in">uint2</span>(GroupThreadIndex % (GROUP_SIZE_Y * <span class="number">2</span>), GroupThreadIndex / (GROUP_SIZE_X * <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>Finally, blur the input texture. Here is the code copied from CryEngine’s Gaussian blur implementation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> weights[<span class="number">15</span>] = &#123; <span class="number">153</span>, <span class="number">816</span>, <span class="number">3060</span>, <span class="number">8568</span>, <span class="number">18564</span>, <span class="number">31824</span>, <span class="number">43758</span>, <span class="number">48620</span>, <span class="number">43758</span>, <span class="number">31824</span>, <span class="number">18564</span>, <span class="number">8568</span>, <span class="number">3060</span>, <span class="number">816</span>, <span class="number">153</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> weightSum = <span class="number">262106.0</span>;</span><br><span class="line"></span><br><span class="line">float2 coords = <span class="built_in">float2</span>(UVCoord) * bloomTexSize.zw - bloomParams.xy * <span class="number">7.0</span>;</span><br><span class="line">half3 vColor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	vColor += <span class="built_in">GetTexture2DLod</span>(BloomFinal_Tx2Tx_Source, BloomFinal_Tx2Tx_Sampler, coords,<span class="number">0.0</span>).rgb * (weights[i] / weightSum);</span><br><span class="line">	coords += bloomParams.xy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BloomFinal_OutputUAV[UVCoord] = <span class="built_in">float4</span>(vColor,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>As Cryengine does not support indirect compute shaders, we must expand its renderer to support them.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDeviceComputeCommandInterfaceImpl::DispatchIndirectImpl</span><span class="params">(<span class="type">const</span> CDeviceBuffer* pBuffer, uint32 Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> CDeviceResourceLayout_Vulkan* pVkLayout = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> CDeviceResourceLayout_Vulkan*&gt;(m_computeState.pResourceLayout.cachedValue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ApplyPendingBindings</span>(<span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">GetVkCommandList</span>(), pVkLayout-&gt;<span class="built_in">GetVkPipelineLayout</span>(), VK_PIPELINE_BIND_POINT_COMPUTE, m_computeState.custom.pendingBindings);</span><br><span class="line">	m_computeState.custom.pendingBindings.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">PendingResourceBarriers</span>();</span><br><span class="line">	<span class="built_in">vkCmdDispatchIndirect</span>(<span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">GetVkCommandList</span>(), pBuffer-&gt;<span class="built_in">GetBuffer</span>()-&gt;<span class="built_in">GetHandle</span>(), Offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the Vulkan capture result of Renderdoc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/vulkanresult.jpg"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Renderdoc result</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bloom input</td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/20230812213557.png"></td>
</tr>
<tr>
<td align="center">bloom output</td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/20230812213642.png"></td>
</tr>
<tr>
<td align="center">tone mapping output</td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/bloomresultj.jpg"></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
