<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lvcheng1229.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="This is a personal implementation of Virtual Shadow Map In CryEngine. AbstractReal-time shadow is an essential field of game development. Without real-time shadow, movable objects will appear floating">
<meta property="og:type" content="article">
<meta property="og:title" content="GPU-Driven Virtual Shadow Map In CryEngine">
<meta property="og:url" content="https://lvcheng1229.github.io/2023/08/01/cesvsm/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="This is a personal implementation of Virtual Shadow Map In CryEngine. AbstractReal-time shadow is an essential field of game development. Without real-time shadow, movable objects will appear floating">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/VSM2.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/image4-768x432.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/VSM2.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/mask.jpg">
<meta property="article:published_time" content="2023-07-31T16:06:36.000Z">
<meta property="article:modified_time" content="2023-12-01T04:46:05.880Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/VSM2.jpg">


<link rel="canonical" href="https://lvcheng1229.github.io/2023/08/01/cesvsm/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://lvcheng1229.github.io/2023/08/01/cesvsm/","path":"2023/08/01/cesvsm/","title":"GPU-Driven Virtual Shadow Map In CryEngine"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>GPU-Driven Virtual Shadow Map In CryEngine | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Abstract"><span class="nav-number">1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Related-techniques-used-in-Virtual-SM"><span class="nav-number">2.</span> <span class="nav-text">Related techniques used in Virtual-SM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Texture"><span class="nav-number">2.1.</span> <span class="nav-text">Virtual Texture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Streaming-Virtual-Texture"><span class="nav-number">2.1.1.</span> <span class="nav-text">Streaming Virtual Texture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime-Virtual-Texture"><span class="nav-number">2.1.2.</span> <span class="nav-text">Runtime Virtual Texture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adaptive-Virtual-Texture"><span class="nav-number">2.1.3.</span> <span class="nav-text">Adaptive Virtual Texture</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPU-Driven-Rendering"><span class="nav-number">2.2.</span> <span class="nav-text">GPU-Driven Rendering</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Prepare-GPU-data"><span class="nav-number">2.2.1.</span> <span class="nav-text">Prepare GPU data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Culling-on-GPU"><span class="nav-number">2.2.2.</span> <span class="nav-text">Culling on GPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Work-Submission"><span class="nav-number">2.2.3.</span> <span class="nav-text">Work Submission</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-brief-introduction-to-Virtual-SM"><span class="nav-number">3.</span> <span class="nav-text">A brief introduction to Virtual-SM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Virtual-Shadow-Map-Implmentation"><span class="nav-number">4.</span> <span class="nav-text">Virtual Shadow Map Implmentation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mask-the-tiles"><span class="nav-number">4.1.</span> <span class="nav-text">Mask the tiles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generate-the-indirect-table"><span class="nav-number">4.2.</span> <span class="nav-text">Generate the indirect table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prepare-GPU-data-1"><span class="nav-number">4.3.</span> <span class="nav-text">Prepare GPU data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPU-Culling"><span class="nav-number">4.4.</span> <span class="nav-text">GPU Culling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Work-Submission-1"><span class="nav-number">4.5.</span> <span class="nav-text">Work Submission</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vulkan-buffer-device-address"><span class="nav-number">4.5.1.</span> <span class="nav-text">Vulkan buffer device address</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Create-a-buffer"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">Create a buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vulkan-GLSL"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">Vulkan GLSL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vulkan-NV-device-generated-commands"><span class="nav-number">4.5.2.</span> <span class="nav-text">Vulkan NV device-generated commands</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Define-indirect-command-layout"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">Define indirect command layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Create-PSO-and-proprocess-buffer"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">Create PSO and proprocess buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Execution-generated-command-and-perform-shadow-rendering"><span class="nav-number">4.5.2.3.</span> <span class="nav-text">Execution generated command and perform shadow rendering</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shadow-Mask-Generation"><span class="nav-number">4.6.</span> <span class="nav-text">Shadow Mask Generation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future-Work"><span class="nav-number">4.7.</span> <span class="nav-text">Future Work</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/08/01/cesvsm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="GPU-Driven Virtual Shadow Map In CryEngine | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GPU-Driven Virtual Shadow Map In CryEngine
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-01 00:06:36" itemprop="dateCreated datePublished" datetime="2023-08-01T00:06:36+08:00">2023-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-01 12:46:05" itemprop="dateModified" datetime="2023-12-01T12:46:05+08:00">2023-12-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>This is a personal implementation of Virtual Shadow Map In CryEngine.</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Real-time shadow is an essential field of game development. Without real-time shadow, movable objects will appear floating on the ground and out of tune with the surrounding environment, which decreases game reality. The most used real-time shadow technique is shadow mapping. This technique causes two artifacts: shadow acne and aliasing. The reason behind these artifacts is that many pixels on the screen correspond to one texel on the shadow map. </p>
<p>Ideally, we can solve these problems by allocating an infinite shadow map texture. However, we can’t do this, since video memory is limited. For real-time shadow rendering, most games employ CSM (cascade shadow map) to achieve a balance between shadow map quality and game performance. The key idea of CSM is to render a high-quality shadow map for the scene closer to the camera and decrease the shadow quality for further objects.</p>
<p>Virtual shadow map is a possible solution to solving these problems. The key idea of Virtual-SM are:1. Only render shadow casters whose shadow can be seen by the camera. 2. Assume the video memory and shadow map texture is large enough (like virtual memory). 3. Manage the scene’s objects and dispatch draw commands on the GPU.</p>
<h1 id="Related-techniques-used-in-Virtual-SM"><a href="#Related-techniques-used-in-Virtual-SM" class="headerlink" title="Related techniques used in Virtual-SM"></a>Related techniques used in Virtual-SM</h1><p>Before discussing Virtual-SM, we will introduce some related techniques: virtual texture and GPU-driven rendering, since Virtual-SM’s idea is similar to the above techniques.</p>
<h2 id="Virtual-Texture"><a href="#Virtual-Texture" class="headerlink" title="Virtual Texture"></a>Virtual Texture</h2><p>The virtual texture is proposed based on a technique called mega texture. Like virtual memory in OS, virtual texture assumes the texture resolution is large enough and does not require the entire texture to be loaded. Instead, we only need to load the part of the texture that is actually used in the current view.</p>
<p>Virtual texture has many variations depending on the situation: streaming virtual texture (SVT), run-time virtual texture (RVT), and its improved version adaptive virtual texture (AVT). The ideas behind SVT&#x2F;RVT&#x2F;AVT are also contained in the Virtual-SM.</p>
<h3 id="Streaming-Virtual-Texture"><a href="#Streaming-Virtual-Texture" class="headerlink" title="Streaming Virtual Texture"></a>Streaming Virtual Texture</h3><p>Streaming virtual texture has four parts:</p>
<p>1.Divided the virtual texture into NxN tiles or pages.<br>2.Collect the tile and the mipmap of the texture required in the current view. This step can be executed in a separate pass or combined with the PreZ &#x2F; GBuffer Pass.<br>3.Feedback and analyze the results and load the texture tiles used.<br>4.Construct and update the indirect texture, which stores the coordinates mapping from virtual texture to physical texture.</p>
<p>Compared to mipmap texture streaming, SVT has the following advantages:</p>
<p>1.Save video memory (we only load the texture tiles required).<br>2.Finer granularity (the minimum load unit is texture tile rather than texture mip).<br>3.More accurately (mip texture streaming is computed on CPU and will get wrong results for complex texture types, such as Atlas. SVT is computed on the GPU based on the ddx&#x2F;ddy operation).</p>
<h3 id="Runtime-Virtual-Texture"><a href="#Runtime-Virtual-Texture" class="headerlink" title="Runtime Virtual Texture"></a>Runtime Virtual Texture</h3><p>The texture content of SVT is loaded from the disk, that is, generated offline. And RVT generates texture content at runtime. It is most used in terrain rendering. The key idea of RVT in terrain rendering is caching the texture blend result into a runtime virtual texture. This has several advantages compared to the SVT and traditional splat map method:</p>
<p>1.The texture size is too large to store on the disk if we employ SVT to blend the terrain texture offline<br>2.We need to sample many times for terrain textures (normal &#x2F; base color&#x2F;splat map) for the traditional splat map method. There are only four channels in a splat map, so we can only record four terrain weights, which limits the art effect.<br>3.RVT has better performance than the splat map method, and the texture size stored on disk is smaller than SVT. In other words, RVT is a compromise solution to SVT and splat map.</p>
<h3 id="Adaptive-Virtual-Texture"><a href="#Adaptive-Virtual-Texture" class="headerlink" title="Adaptive Virtual Texture"></a>Adaptive Virtual Texture</h3><p>Adaptive virtual texture is an improved version based on the RVT. We will get a large indirect table if the terrain is wide enough. AVT solves this problem by allocating different VT sizes depending on camera distance.</p>
<h2 id="GPU-Driven-Rendering"><a href="#GPU-Driven-Rendering" class="headerlink" title="GPU-Driven Rendering"></a>GPU-Driven Rendering</h2><p>In virtual shadow map, each shadow map tile corresponds to a frustum. This means that Virtual-SM will perform culling many times, which is unaffordable for the CPU. GPU-driven rendering can solve these problems by moving culling and submitting tasks from CPU to GPU. Let’s introduce the basic GPU-driven pipeline first. </p>
<p>GPU-driven rendering pipeline has three parts: preparing GPU data, culling on GPU, and work submission.</p>
<h3 id="Prepare-GPU-data"><a href="#Prepare-GPU-data" class="headerlink" title="Prepare GPU data"></a>Prepare GPU data</h3><p>1.Before submitting data to the GPU, we can perform a coarse quad tree culling on the CPU, which reduces the data uploaded to the GPU.<br>2.Prepare the data that will be updated. This includes 1. instance&#x2F;primitive data (transform&#x2F;lod factor&#x2F;bounding box), 2. Light map data etc.<br>3.Batch draw calls and update the GPU data required in the next step</p>
<h3 id="Culling-on-GPU"><a href="#Culling-on-GPU" class="headerlink" title="Culling on GPU"></a>Culling on GPU</h3><p>Culling on GPU, contains the following steps:<br>1.Instance culling, perform frustum culling and HIZ culling on GPU. And generate the cluster chunk for those instances passing culling.<br>2.Perform the frustum and occlusion culling for each cluster based on the cluster’s transform and bound. And perform back-face culling based on cluster orientation precomputed offline.<br>3.Index buffer compaction, culling the index unused.</p>
<h3 id="Work-Submission"><a href="#Work-Submission" class="headerlink" title="Work Submission"></a>Work Submission</h3><p>Generate commands buffer and use indirect draw to submit the work.</p>
<h1 id="A-brief-introduction-to-Virtual-SM"><a href="#A-brief-introduction-to-Virtual-SM" class="headerlink" title="A brief introduction to Virtual-SM"></a>A brief introduction to Virtual-SM</h1><p>Virtual-SM assumes the shadow map resolution is large enough, similar to virtual texture. The shadow map is split into many tiles and only renders the tiles required in the current view.</p>
<p>In general, Virtual-SM can be divided into the following passes:</p>
<p>1.Mask the tiles required in the current view based on the Pre-Z depth texture.<br>2.Generate an indirect table that maps coordinates from virtual texture to physical texture.<br>3.Collect shadow caster objects and prepare GPU data.<br>4.Using GPU to cull shadow casters and generate indirect draw commands.<br>5.Work submission and shadow projection.<br>6.Generate a shadow mask texture.</p>
<h1 id="Virtual-Shadow-Map-Implmentation"><a href="#Virtual-Shadow-Map-Implmentation" class="headerlink" title="Virtual Shadow Map Implmentation"></a>Virtual Shadow Map Implmentation</h1><h2 id="Mask-the-tiles"><a href="#Mask-the-tiles" class="headerlink" title="Mask the tiles"></a>Mask the tiles</h2><p>We allocate a buffer with the size of the virtual tile number. This buffer stores whether the corresponding tile is required by the current view.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_vsmTileFlagBuffer.<span class="built_in">Create</span>(VSM_VIRTUAL_TILE_SIZE_WH * VSM_VIRTUAL_TILE_SIZE_WH, <span class="built_in">sizeof</span>(uint32), DXGI_FORMAT_R32_UINT, CDeviceObjectFactory::BIND_SHADER_RESOURCE | CDeviceObjectFactory::BIND_UNORDERED_ACCESS, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>Reconstruct the world position from the input scene depth texture, and project it into shadow space. Then, mask the tiles if UV is valid.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float4 worldPosition = ......;</span><br><span class="line">float4 shadowScreenPOS = <span class="built_in">mul</span>(worldPosition,c_tileFlagGenConstants.lightViewProj);</span><br><span class="line">shadowScreenPOS.xyz /= shadowScreenPOS.w;</span><br><span class="line"></span><br><span class="line">float2 uvVSM = ......;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">all</span>(<span class="built_in">abs</span>(uvVSM) &lt; <span class="number">1.0f</span>))</span><br><span class="line">&#123;</span><br><span class="line">    uint2 uvBuffer = uvVSM * c_tileFlagGenConstants.vsmVirtualTileNum.xy;</span><br><span class="line">    uint bufferIndex = uvBuffer.y * c_tileFlagGenConstants.vsmVirtualTileNum.x + uvBuffer.x;</span><br><span class="line">    p1_vsmTileFlags[bufferIndex] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Generate-the-indirect-table"><a href="#Generate-the-indirect-table" class="headerlink" title="Generate the indirect table"></a>Generate the indirect table</h2><p>Allocate an indirect table buffer with the virtual tile number size. This table maps the virtual texture tile to the physical texture tile. And we need a buffer to count the current tile number.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_vsmTileTableBuffer.<span class="built_in">Create</span>(VSM_VIRTUAL_TILE_SIZE_WH * VSM_VIRTUAL_TILE_SIZE_WH, <span class="built_in">sizeof</span>(uint32), DXGI_FORMAT_UNKNOWN, CDeviceObjectFactory::USAGE_STRUCTURED | CDeviceObjectFactory::BIND_UNORDERED_ACCESS | CDeviceObjectFactory::BIND_SHADER_RESOURCE, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line">m_vsmValidTileCountBuffer.<span class="built_in">Create</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(uint32), DXGI_FORMAT_UNKNOWN, CDeviceObjectFactory::USAGE_STRUCTURED | CDeviceObjectFactory::BIND_UNORDERED_ACCESS, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>Generate an indirect table from the tile flag buffer. For each virtual texture tile, compute its physical texture tile index. If this tile is masked as required, use InterlockedAdd to count the tile index, and store the result into indirect table.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p2_vsmTileFlags[bufferIndex] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p2_validTileCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>,<span class="built_in">uint</span>(<span class="number">1</span>),tileIndex);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">p2_vsmTileTable[bufferIndex] = tileIndex;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/VSM2.jpg"></p>
<h2 id="Prepare-GPU-data-1"><a href="#Prepare-GPU-data-1" class="headerlink" title="Prepare GPU data"></a>Prepare GPU data</h2><p>Each Virtual-SM tile correspond to a shadow frustum, which is incompatible with the existing frustum type in CryEngine. We need to add a new frustum type: e_VSM. Then, create and update the e_VSM Frustum in the function UpdateGSMLightSourceShadowFrustum. Additionally, skip the shadow casters culling in COctreeNode::UpdateCullMask, since vsm perform culling on GPU. </p>
<p>After that, all rendered items are stored in ShadowView. With the data required for GPU culling ready, we can update the GPU data. GPU data contains the following members:</p>
<p>1.Instance data per render item. It contains two members:<br>Instance transform and instance bounding box, used for GPU culling.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SRenderItemGPUData</span></span><br><span class="line">&#123;</span><br><span class="line">	Matrix44 m_Matrix;</span><br><span class="line">	</span><br><span class="line">	Vec3 m_boundingBoxCenter;</span><br><span class="line">	<span class="type">float</span> padding_0;</span><br><span class="line">	Vec3 m_boundingBoxExtent;</span><br><span class="line">	<span class="type">float</span> padding_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.GPU draw command, used for indirect draw, contains the following members:<br>2.1 Shader group index (Index to PSO array, will be described below).<br>2.2 Constant buffers (Including per-object buffer and per-shadow frustum buffer).<br>2.3 Index buffer and vertex buffer<br>2.4 The indirectct draw command</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CDeviceGPUDrawCmd</span></span><br><span class="line">&#123;</span><br><span class="line">	uint32 m_shaderGroupIndex;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;CDeviceBuffer*&gt; m_constBuffers;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> CDeviceInputStream* m_indexStreamSet;</span><br><span class="line">	<span class="type">const</span> CDeviceInputStream* m_vertexStreamSet;</span><br><span class="line"></span><br><span class="line">	int32 IndexCountPerInstance;</span><br><span class="line">	int32 InstanceCount;</span><br><span class="line">	int32 StartIndexLocation;</span><br><span class="line">	int32  BaseVertexLocation;</span><br><span class="line">	uint32 StartInstanceLocation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Iterate over all rendered items, get the data needed, and fill the culling data buffer and draw the command buffer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> SRendItem&amp; ri = (*renderItems)[i];</span><br><span class="line">......</span><br><span class="line"><span class="comment">//gpu culling data</span></span><br><span class="line">m_riGpuCullingData.<span class="built_in">push_back</span>(</span><br><span class="line">	SRenderItemGPUData</span><br><span class="line">	&#123;</span><br><span class="line">		ri.pCompiledObject-&gt;<span class="built_in">GetInstancingData</span>().matrix,</span><br><span class="line">		ri.pCompiledObject-&gt;m_aabb.<span class="built_in">GetCenter</span>(),</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		ri.pCompiledObject-&gt;m_aabb.max - ri.pCompiledObject-&gt;m_aabb.<span class="built_in">GetCenter</span>(),</span><br><span class="line">		<span class="number">0</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pso array todo:cache pso</span></span><br><span class="line">m_renderItemsPSO.<span class="built_in">push_back</span>(ri.pCompiledObject-&gt;m_pso[m_stageID][m_passID].<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//indirect draw command</span></span><br><span class="line">std::vector&lt;CDeviceBuffer*&gt;constBuffers;</span><br><span class="line">constBuffers.<span class="built_in">push_back</span>(ri.pCompiledObject-&gt;m_perDrawCB-&gt;m_buffer);</span><br><span class="line">constBuffers.<span class="built_in">push_back</span>(ri.pCompiledObject-&gt;m_perDrawCB-&gt;m_buffer);<span class="comment">//placeholder buffer,set on gpu</span></span><br><span class="line">m_gpuDrawCommands.<span class="built_in">push_back</span>(</span><br><span class="line">	CDeviceGPUDrawCmd</span><br><span class="line">	&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="GPU-Culling"><a href="#GPU-Culling" class="headerlink" title="GPU Culling"></a>GPU Culling</h2><p>Create and update the Frustum projection buffer, store the project matrix and Frustum offset. Then, gather the GPU addresses of these buffers, and upload the address buffer to the GPU.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint32 indexX = <span class="number">0</span>; indexX &lt; VSM_VIRTUAL_TILE_SIZE_WH; indexX++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (uint32 indexY = <span class="number">0</span>; indexY &lt; VSM_VIRTUAL_TILE_SIZE_WH; indexY++)</span><br><span class="line">	&#123;</span><br><span class="line">		Matrix44A lightViewProjMatrix = ......;</span><br><span class="line">		SShadowProjectMatrix ShadowProjectMatrix&#123; lightViewProjMatrix ,indexX,indexY &#125;;</span><br><span class="line">		m_vsmFrustumProjectBuffer[indexX + indexY * VSM_VIRTUAL_TILE_SIZE_WH]-&gt;<span class="built_in">UpdateBuffer</span>(&amp;ShadowProjectMatrix,<span class="built_in">sizeof</span>(SShadowProjectMatrix));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Perform GPU culling. It contains the following steps:<br>1.Compute the aabb corner of the bounding box</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float4 corner[<span class="number">8</span>];</span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span>(uint i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    corner[i] = <span class="built_in">float4</span>(rhiGpuCullingData[index].boundingBoxCenter ,<span class="number">0</span>)  + <span class="built_in">float4</span>(rhiGpuCullingData[index].boundingBoxExtent,<span class="number">0</span>) * BoundingBoxOffset[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Project it to shadow space and get the coverage of the shadow tile of this bonding box</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span>(uint j = <span class="number">0</span>; j &lt; <span class="number">8</span> ; j++)</span><br><span class="line">&#123;</span><br><span class="line">    float4 screenPosition = <span class="built_in">mul</span>(<span class="built_in">float4</span>(corner[j].xyz,<span class="number">1.0f</span>),c_VSMCmdBuildConstants.lightViewProj);</span><br><span class="line">    screenPosition.xyz/=screenPosition.w;</span><br><span class="line">    float2 screenUV = ......;</span><br><span class="line">    uvMin = <span class="built_in">min</span>(uvMin,screenUV);</span><br><span class="line">    uvMax = <span class="built_in">max</span>(uvMax,screenUV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.For each tile covered by a bounding box, create a GPU draw command if this tile is masked as visible in the first pass. Then use a counter buffer and RWStructuredBuffer to simulate the append buffer. Get the address of the corresponding Frustum constant buffer, and assign this value to the GPU draw command. Get the index of this draw command by InterlockedAdd, then write the result to the outputCommands buffer for work submission. This may split a draw call into many DC, we can improve it in future work.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(uint indexX = tileIndexMin.x ; indexX &lt;= tileIndexMax.x ; indexX++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(uint indexY = tileIndexMin.y ; indexY &lt;= tileIndexMax.y ; indexY++)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span>(visible &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uint cmdIndex = <span class="number">0</span>;</span><br><span class="line">            p3_vsmCmdCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>,<span class="built_in">uint</span>(<span class="number">1</span>),cmdIndex);</span><br><span class="line">            </span><br><span class="line">            SvsmDrawCmd cmd = (SvsmDrawCmd)<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cmdIndex &lt; c_VSMCmdBuildConstants.cmdBuildPara.z)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.addressPerVSMView = frustumMatrixAddress[indexY * tileIndexMax.x + indexX];</span><br><span class="line">                outputCommands[cmdIndex] = cmd;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Work-Submission-1"><a href="#Work-Submission-1" class="headerlink" title="Work Submission"></a>Work Submission</h2><p>We need to introduce two prerequisite techniques, Vulkan buffer device address and Vulkan NV device-generated commands. They are essential parts of the GPU work submission.</p>
<h3 id="Vulkan-buffer-device-address"><a href="#Vulkan-buffer-device-address" class="headerlink" title="Vulkan buffer device address"></a>Vulkan buffer device address</h3><p>Vulkan buffer device address extension allows to fetch raw GPU pointers to a buffer and pass it for usage in a shader code.</p>
<h4 id="Create-a-buffer"><a href="#Create-a-buffer" class="headerlink" title="Create a buffer"></a>Create a buffer</h4><p>To create a buffer that enables BDA, we need to set VKBufferCreateInfo usage as VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, indicating that this buffer can be accessed by device address in the shader. And set the VMA allocate flag to VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkMemoryAllocateFlagsInfoKHR flags_info&#123;VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR&#125;;</span><br><span class="line">flags_info.flags             = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;</span><br><span class="line">memory_allocation_info.pNext = &amp;flags_info;</span><br></pre></td></tr></table></figure>

<p>Use vkGetBufferDeviceAddressKHR to get the buffer address. The return result type is VkDeviceAddress (uint64_t).</p>
<h4 id="Vulkan-GLSL"><a href="#Vulkan-GLSL" class="headerlink" title="Vulkan GLSL"></a>Vulkan GLSL</h4><p>Here is an example of a buffer device address. We get the GL_EXT_buffer_reference extension which allows us to declare buffer blocks not as SSBOs, but faux pointer types instead.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#extension GL_EXT_buffer_reference : enable</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(buffer_reference, buffer_reference_align=<span class="number">16</span>, scalar) readonly buffer ExamplelBuffer &#123;</span><br><span class="line">  BufferData  data;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">layout</span>(push_constant, scalar) uniform pushConstants &#123;</span><br><span class="line">  <span class="built_in">layout</span>(offset=<span class="number">8</span>)</span><br><span class="line">  ExamplelBuffer v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>buffer_reference tags the type accordingly, and buffer_reference_align is used to mark that any pointer which is of this type is at least 16 bytes aligned. </p>
<p>Finally, we place the buffer reference inside the push constant. Buffer_reference can also be placed inside SSBO or UBO. The reason we employ push constant is that Device Generated Commands discussed later only support push constant.</p>
<h3 id="Vulkan-NV-device-generated-commands"><a href="#Vulkan-NV-device-generated-commands" class="headerlink" title="Vulkan NV device-generated commands"></a>Vulkan NV device-generated commands</h3><p>One problem with existing indirect techniques is that the command buffer must be prepared for the worst-case scenario on the CPU. You may also require more memory than necessary for the distribution of indirect commands, given that it is not known which state buckets they will end up in. To solve these problems, this extension adds further capabilities, such as the ability to switch between different shaders.</p>
<p>The following steps generate commands on the device:</p>
<p>1.Define a sequence of commands to be generated, using a VkIndirectCommandsLayoutNV object.<br>2.For the ability to change shaders, create the graphics pipelines with VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV and then create an aggregate graphics pipeline that imports those pipelines as graphics shader groups using VkGraphicsPipelineShaderGroupsCreateInfoNV, which extends VkGraphicsPipelineCreateInfo.<br>3.Create a preprocess buffer based on sizing information acquired using vkGetGeneratedCommandsMemoryRequirementsNV.<br>4.Fill the input buffers for the generation step and set up the VkGeneratedCommandsInfoNV struct accordingly. It is used in preprocessing as well as execution. Some commands require buffer addresses, which can be acquired using vkGetBufferDeviceAddress.<br>5.Run the execution via vkCmdExecuteGeneratedCommandsNV.</p>
<p>Most engines don’t support Vulkan device-generated commands. We need to develop this extension for CryEngine. The first step is to upgrade CryEngine‘s Vulkan SDK version, since it does not match the current DGC extension version :(</p>
<h4 id="Define-indirect-command-layout"><a href="#Define-indirect-command-layout" class="headerlink" title="Define indirect command layout"></a>Define indirect command layout</h4><p>Create indirect command layout tokens. It contains five types:</p>
<p>1.Shader group type, indexing to PSO this command used.<br>2.Index&#x2F;Vertex buffer type<br>3.Push constant type, storing the constant buffer this command requires.<br>4.Draw indexed type, which describes the draw parameters, such as instance count, start vertex location,etc.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TMP_RENDER_API</span> SDeviceResourceIndirectLayoutToken</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum  class</span> <span class="title class_">ETokenType</span> : uint8</span><br><span class="line">	&#123;</span><br><span class="line">		TT_ShaderGroup,</span><br><span class="line">		TT_IndexBuffer,</span><br><span class="line">		TT_VertexBuffer,</span><br><span class="line">		TT_PushConstant,</span><br><span class="line">		TT_DrawIndexd,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	ETokenType m_tokenType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//push constant</span></span><br><span class="line">	CDeviceResourceLayoutPtr m_pDeviceResourceLayout;</span><br><span class="line">	EShaderStage m_pcShaderStage;</span><br><span class="line">	uint32 m_pcOffset;</span><br><span class="line">	uint32 m_pcSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Then, add tokens to the indirect desc. Since the virtual shadow map draw command needs two constant buffers, the size of the push constant is sizeof(VkDeviceAddress) * 2.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   ......</span><br><span class="line">SDeviceResourceLayoutDesc layoutDesc;</span><br><span class="line">layoutDesc.<span class="built_in">SetResourceSet</span>(EResourceLayoutSlot_PerPassRS, m_perPassResources);</span><br><span class="line">layoutDesc.<span class="built_in">AddPushConstant</span>(EShaderStage_Vertex | EShaderStage_Pixel, <span class="built_in">sizeof</span>(uint64) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">m_pResourceLayout = <span class="built_in">GetDeviceObjectFactory</span>().<span class="built_in">CreateResourceLayout</span>(layoutDesc);<span class="comment">//see m_graphicsPipeline.CreateScenePassLayout(m_perPassResources);</span></span><br><span class="line">m_perPassResources.<span class="built_in">AcceptChangedBindPoints</span>();</span><br><span class="line"></span><br><span class="line">SDeviceResourceIndirectLayoutDesc deviceResourceIndirectLayoutDesc;</span><br><span class="line">deviceResourceIndirectLayoutDesc.<span class="built_in">AddPushConstant</span>(m_pResourceLayout, EShaderStage_Vertex | EShaderStage_Pixel, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint64) * <span class="number">2</span>);</span><br><span class="line">......</span><br><span class="line">deviceResourceIndirectLayoutDesc.<span class="built_in">AddDrawIndexed</span>();</span><br></pre></td></tr></table></figure>
<p>For each RHI layout token, convert it to Vulkan Layout token. Push constant needs to be handled specially, we should assign VkPipelineLayout to member pushconstantPipelineLayout.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;VkIndirectCommandsLayoutTokenNV&gt; inputInfos;</span><br><span class="line"></span><br><span class="line">uint32 offsetGloabl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = desc.m_indirectLayoutTokens.<span class="built_in">begin</span>(); iter != desc.m_indirectLayoutTokens.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	VkIndirectCommandsTokenTypeNV tokenTypeNV = <span class="built_in">ConvertToVKIndirectCmdType</span>(iter-&gt;m_tokenType);</span><br><span class="line">	VkIndirectCommandsLayoutTokenNV input = &#123; VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV, <span class="number">0</span>,tokenTypeNV &#125;;</span><br><span class="line">	input.stream = <span class="number">0</span>;</span><br><span class="line">	input.offset = offsetGloabl;</span><br><span class="line"></span><br><span class="line">	offsetGloabl += <span class="built_in">ConvertToTTSize</span>(iter-&gt;m_tokenType, iter-&gt;m_pcSize);</span><br><span class="line">       </span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tokenTypeNV == VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV)</span><br><span class="line">	&#123;</span><br><span class="line">		input.pushconstantPipelineLayout = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CDeviceResourceLayout_Vulkan*&gt;(iter-&gt;m_pDeviceResourceLayout.<span class="built_in">get</span>())-&gt;<span class="built_in">GetVkPipelineLayout</span>();</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inputInfos.<span class="built_in">push_back</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> interleavedStride = offsetGloabl;</span><br><span class="line"></span><br><span class="line">VkIndirectCommandsLayoutCreateInfoNV genInfo = &#123; VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV &#125;;</span><br><span class="line">genInfo.tokenCount = (<span class="type">uint32_t</span>)inputInfos.<span class="built_in">size</span>();</span><br><span class="line">genInfo.pTokens = inputInfos.<span class="built_in">data</span>();</span><br><span class="line">genInfo.streamCount = <span class="number">1</span>;</span><br><span class="line">genInfo.pStreamStrides = &amp;interleavedStride;</span><br><span class="line"></span><br><span class="line">VkResult result = VK_RESULT_MAX_ENUM;</span><br><span class="line"><span class="keyword">if</span> (Extensions::EXT_device_generated_commands::IsSupported)</span><br><span class="line">&#123;</span><br><span class="line">	result = Extensions::EXT_device_generated_commands::<span class="built_in">CmdCreateIndirectCommandsLayout</span>(m_pDevice-&gt;<span class="built_in">GetVkDevice</span>(), &amp;genInfo, <span class="literal">NULL</span>, &amp;indirectCmdsLayout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In addition, we employ the interleaved command layout in Virtual-SM, which is an array of structures (AOS). It leads to generating dynamic commands on GPU more easily. DGC provides a structure of arrays (SoA) layout for compact, cache-friendly streams.</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/image4-768x432.png"></p>
<h4 id="Create-PSO-and-proprocess-buffer"><a href="#Create-PSO-and-proprocess-buffer" class="headerlink" title="Create PSO and proprocess buffer"></a>Create PSO and proprocess buffer</h4><p>For the ability to change shaders, create the graphics pipelines with VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV and then create an aggregate graphics pipeline that imports those pipelines as graphics shader groups using VkGraphicsPipelineShaderGroupsCreateInfoNV, which extends VkGraphicsPipelineCreateInfo.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">VkGraphicsPipelineShaderGroupsCreateInfoNV groupsCreateInfo = &#123; VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV &#125;;</span><br><span class="line">&#123;</span><br><span class="line">	std::vector&lt;VkPipeline&gt; referencedPipelines;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> m = <span class="number">1</span>; m &lt; psoDesc.indirectPso.<span class="built_in">size</span>(); m++)</span><br><span class="line">	&#123;</span><br><span class="line">		referencedPipelines.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;CDeviceGraphicsPSO_Vulkan*&gt;(psoDesc.indirectPso[m])-&gt;<span class="built_in">GetVkPipeline</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	groupsCreateInfo.pPipelines = referencedPipelines.<span class="built_in">data</span>();</span><br><span class="line">	groupsCreateInfo.pipelineCount = (<span class="type">uint32_t</span>)referencedPipelines.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m = 0;</span></span><br><span class="line">	VkGraphicsShaderGroupCreateInfoNV shaderGroup = &#123; VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV &#125;;</span><br><span class="line">		</span><br><span class="line">    ......</span><br><span class="line">	groupsCreateInfo.groupCount = <span class="number">1u</span>;</span><br><span class="line">	groupsCreateInfo.pGroups = &amp;shaderGroup;</span><br><span class="line">	graphicsPipelineCreateInfo.pNext = &amp;groupsCreateInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Create a preprocess buffer based on the indirect layout and indirect PSO prepared above. Preprocess buffer stores the information to execute generated commands.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">m_preprocessBuffer.<span class="built_in">CreatePreprocessBuffer</span>(CRenerItemGPUDrawer::m_maxDrawSize, m_pResourceIndirectLayout, m_pIndirectGraphicsPSO);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDevice::CreatePreProcessBuffer</span><span class="params">(uint32 drawCount, VkIndirectCommandsLayoutNV indirectCmdsLayout, VkPipeline indirectPSO, CBufferResource* pOutputResource, uint32 countOffset, uint32&amp; outSize)</span> threadsafe</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkGeneratedCommandsMemoryRequirementsInfoNV memInfo = &#123; VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV &#125;;</span><br><span class="line">	memInfo.maxSequencesCount = drawCount;</span><br><span class="line">	memInfo.indirectCommandsLayout = indirectCmdsLayout;</span><br><span class="line">	memInfo.pipeline = indirectPSO;</span><br><span class="line">	memInfo.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</span><br><span class="line"></span><br><span class="line">	VkMemoryRequirements2 memReqs = &#123; VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 &#125;;</span><br><span class="line">	<span class="keyword">if</span> (Extensions::EXT_device_generated_commands::IsSupported)</span><br><span class="line">	&#123;</span><br><span class="line">		Extensions::EXT_device_generated_commands::<span class="built_in">CmdGetGeneratedCommandsMemoryRequirements</span>(<span class="built_in">GetVkDevice</span>(), &amp;memInfo, &amp;memReqs);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	VkBufferCreateInfo createInfo = &#123; VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO &#125;;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	VkBuffer hVkResource = VK_NULL_HANDLE;</span><br><span class="line">	<span class="built_in">VK_ASSERT</span>(<span class="built_in">vkCreateBuffer</span>(<span class="built_in">GetVkDevice</span>(), &amp;createInfo, <span class="literal">nullptr</span>, &amp;hVkResource));</span><br><span class="line">	......</span><br><span class="line">	CMemoryHandle boundMemory;</span><br><span class="line">	<span class="keyword">if</span> ((boundMemory = <span class="built_in">GetHeap</span>().<span class="built_in">Allocate</span>(memReqs.memoryRequirements, kHeapTargets)))</span><br><span class="line">	&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Execution-generated-command-and-perform-shadow-rendering"><a href="#Execution-generated-command-and-perform-shadow-rendering" class="headerlink" title="Execution generated command and perform shadow rendering"></a>Execution generated command and perform shadow rendering</h4><p>All the data we needed for shadow map rendering is ready, it contains:</p>
<p>1.Culled GPU draw command buffer<br>2.Counter buffer<br>3.Indirect layout<br>4.PSO<br>5.Preprocess buffer</p>
<p>Fill in VkGeneratedCommandsInfoNV with the information prepared above and perform the final vkCommand : vkCmdExecuteGeneratedCommandsNV.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#vkextbegin</span></span><br><span class="line">[[vk::push_constant]]</span><br><span class="line">SCbPointer cbPointer;</span><br><span class="line"><span class="meta">#vkextend</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSMProjectPS</span><span class="params">(vtxOut IN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#vkextbegin</span></span><br><span class="line">    uint2 IndexXY = vk::<span class="built_in">RawBufferLoad</span>&lt;uint2&gt;(cbPointer.PerViewAddress + <span class="number">16</span>,<span class="number">4</span>);</span><br><span class="line"><span class="meta">#vkextend</span></span><br><span class="line"></span><br><span class="line">    uint PageTableIndex = PagetableInfos[IndexXY].x;<span class="comment">//TODO : Move To Vertex Shader</span></span><br><span class="line">    uint PhysicalIndexX = PageTableIndex % <span class="built_in">uint</span>(PhysicalTileWidthNum);</span><br><span class="line">    uint PhysicalIndexY = PageTableIndex / <span class="built_in">uint</span>(PhysicalTileWidthNum);</span><br><span class="line">    </span><br><span class="line">    float2 UVWtrite = IN.PositionIn.xy / TileSize;</span><br><span class="line"></span><br><span class="line">    float2 WritePos = <span class="built_in">float2</span>(PhysicalIndexX,PhysicalIndexY) + UVWtrite;</span><br><span class="line">    WritePos/=PhysicalTileWidthNum;</span><br><span class="line">    WritePos*=PhysicalSize;</span><br><span class="line"></span><br><span class="line">    uint UintDepth = IN.PositionIn.z * (<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">InterlockedMax</span>(PhysicalShadowDepthTexture[<span class="built_in">uint2</span>(WritePos)],UintDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the shader code, we get the page table index by vk::RawBufferLoad for the address stored in vk::push_constant SCbPointer. We add a custom parse step for the Vulkan-HLSL extension, since CryEngine couldn’t parse these Vulkan tokens.</p>
<p>Transform the depth to uint, and use InterlockedMax to store the result depth.</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/VSM2.jpg"></p>
<h2 id="Shadow-Mask-Generation"><a href="#Shadow-Mask-Generation" class="headerlink" title="Shadow Mask Generation"></a>Shadow Mask Generation</h2><p>By looking up the indirect page table with the virtual tile index, we get the physical tile index when creating the shadow mask texture.And get the physical shadow texture coords by TileIndex and SubTileUV.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uint ObjectShadowDepth = (ShadowScreenPOS.z)* (<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ComputeShadowFactor</span><span class="params">(float2 UVShadowSpace ,uint ObjectShadowDepth , uint Bias)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint2 TileIndexXY = <span class="built_in">uint2</span>(UVShadowSpace * PageNum <span class="comment">/*- 0.5f*/</span>);</span><br><span class="line">    uint PageTableIndex = PagetableInfos[TileIndexXY].x;</span><br><span class="line"></span><br><span class="line">    uint PhysicalIndexX = PageTableIndex % <span class="built_in">uint</span>(PhysicalTileWidthNum);</span><br><span class="line">    uint PhysicalIndexY = PageTableIndex / <span class="built_in">uint</span>(PhysicalTileWidthNum);</span><br><span class="line"></span><br><span class="line">    float2 SubTileUV = (UVShadowSpace * PageNum) - <span class="built_in">uint2</span>(UVShadowSpace * PageNum);</span><br><span class="line">    float2 ShadowDepthPos = <span class="built_in">float2</span>(PhysicalIndexX,PhysicalIndexY) + SubTileUV; </span><br><span class="line">    ShadowDepthPos/=PhysicalTileWidthNum;</span><br><span class="line">    ShadowDepthPos*=PhysicalSize;</span><br><span class="line"></span><br><span class="line">    uint ShadowDepth = PhysicalShadowDepthTexture[<span class="built_in">uint2</span>(ShadowDepthPos)].x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ObjectShadowDepth + Bias )&lt; ShadowDepth) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/mask.jpg"></p>
<h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>1.Shadow Cache<br>We can cache the shadow page if the camera does not change much, which reduces the draw call executed. Culling dynamic objects at the GPU culling stage. If its corresponding shadow tiles are masked as CACHED, change the tile flag to UNCACHED. After that, cull static objects. If its corresponding tiles are masked as CACHED, cull this draw command and reuse the previous frame’s shadow project result.</p>
<p>2.Virtual-SM clip map<br>We can decrease shadow quality based on the distance from the scene position to the camera. Physical shadow tiles have the same resolution, but their corresponding scene area is different, tiles further from the center correspond to larger areas.</p>
<p>3.Per-pixel projection<br>Currently, we employ per-page projection for virtual-SM implementation. The disadvantage of this solution is that each object may be rendered many times (total render times &#x3D; object number * tiles number covered). We can transfer the per-page projection method to the per-pixel projection method. For shadow projection pixels, we perform a virtual to physical coordinate transfer, and write to the corresponding position.</p>
<p>4.DX12 implementaion</p>
<p>The virtual-SM implementation in Cryengine only supports Vulkan API, but we can transfer it to the DX12 implementation.Here is the corresponding items between Vulkan and Direct12:</p>
<table>
<thead>
<tr>
<th>Vulkan</th>
<th>DX12</th>
</tr>
</thead>
<tbody><tr>
<td>VkIndirectCommandsLayoutTokenNV</td>
<td>D3D12_INDIRECT_ARGUMENT_DESC</td>
</tr>
<tr>
<td>VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV</td>
<td>D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>VkDeviceAddress</td>
<td>D3D12_GPU_VIRTUAL_ADDRESS</td>
</tr>
<tr>
<td>VkBindIndexBufferIndirectCommandNV</td>
<td>D3D12_INDEX_BUFFER_VIEW</td>
</tr>
<tr>
<td>VkDrawIndexedIndirectCommand</td>
<td>D3D12_DRAW_INDEXED_ARGUMENTS</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/30/cepptb/" rel="prev" title="Implement tiled-Based indirect bloom in CryEngine">
                  <i class="fa fa-angle-left"></i> Implement tiled-Based indirect bloom in CryEngine
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/01/cerhivkrt/" rel="next" title="Bindless Vulkan RayTraing In CryEngine[Part1]">
                  Bindless Vulkan RayTraing In CryEngine[Part1] <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
