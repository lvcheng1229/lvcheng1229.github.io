<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lvcheng1229.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="This blog will introduce the personal Vulkan bindless ray tracing implementation in CryEngine and discuss the hardware architecture and theory behind real-time ray tracing. This article is divided int">
<meta property="og:type" content="article">
<meta property="og:title" content="Bindless Vulkan RayTraing In CryEngine[Part1]">
<meta property="og:url" content="https://lvcheng1229.github.io/2023/08/01/cerhivkrt/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="This blog will introduce the personal Vulkan bindless ray tracing implementation in CryEngine and discuss the hardware architecture and theory behind real-time ray tracing. This article is divided int">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-31T16:08:24.000Z">
<meta property="article:modified_time" content="2023-12-02T17:55:51.712Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lvcheng1229.github.io/2023/08/01/cerhivkrt/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://lvcheng1229.github.io/2023/08/01/cerhivkrt/","path":"2023/08/01/cerhivkrt/","title":"Bindless Vulkan RayTraing In CryEngine[Part1]"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Bindless Vulkan RayTraing In CryEngine[Part1] | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RayTracing-Acceleration-Structure"><span class="nav-number">1.</span> <span class="nav-text">RayTracing Acceleration Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-Brief-Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">A Brief Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BVH"><span class="nav-number">1.1.1.</span> <span class="nav-text">BVH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Two-Level-Acceleration-Structure"><span class="nav-number">1.1.2.</span> <span class="nav-text">Two-Level Acceleration Structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Trade-Offs-of-Structure-Building"><span class="nav-number">1.1.3.</span> <span class="nav-text">The Trade-Offs of Structure Building</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tips"><span class="nav-number">1.1.4.</span> <span class="nav-text">Tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deffered"><span class="nav-number">1.1.5.</span> <span class="nav-text">deffered</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ray-Transversal-And-Intersection"><span class="nav-number">1.1.6.</span> <span class="nav-text">Ray Transversal And Intersection</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-Details"><span class="nav-number">1.2.</span> <span class="nav-text">Implementation Details</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vertex-Index-Buffer-Creation"><span class="nav-number">1.2.1.</span> <span class="nav-text">Vertex&#x2F;Index Buffer Creation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Acceleration-structure-construction"><span class="nav-number">1.2.2.</span> <span class="nav-text">Acceleration structure construction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bottom-level-acceleration-structure-construction"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Bottom-level acceleration structure construction</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Construct-the-create-information"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">Construct the create information</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Create-the-acceleration-structure"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">Create the acceleration structure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Build-the-acceleration-structure"><span class="nav-number">1.2.2.1.3.</span> <span class="nav-text">Build the acceleration structure</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extended"><span class="nav-number">1.3.</span> <span class="nav-text">Extended</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BVH-example"><span class="nav-number">1.3.1.</span> <span class="nav-text">BVH example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scene-Cohenrency"><span class="nav-number">1.3.2.</span> <span class="nav-text">Scene Cohenrency</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/08/01/cerhivkrt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Bindless Vulkan RayTraing In CryEngine[Part1] | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Bindless Vulkan RayTraing In CryEngine[Part1]
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-01 00:08:24" itemprop="dateCreated datePublished" datetime="2023-08-01T00:08:24+08:00">2023-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-03 01:55:51" itemprop="dateModified" datetime="2023-12-03T01:55:51+08:00">2023-12-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>This blog will introduce the personal Vulkan bindless ray tracing implementation in CryEngine and discuss the hardware architecture and theory behind real-time ray tracing. This article is divided into four parts: Building the Acceleration Structure, RayTracing Shaders, RayTracing Pipeline and Bindless Ray Tracing.</p>
<p>Before DXR and Vulkan Ray Tracing API, NVIDIA had already developed a ray tracing API called Optix around 2009. Optix is similar to the other two APIs in some respects. By the way, I discovered Optix before Vulkan RayTracing too, since my undergraduate thesis is based on Optix. Almost ten years after the release of Optix, Microsoft released DXR in 2018 and Vulkan TSG released Vulkan RayTracing in 2020. Vulkan and DXR ray tracing are same in many parts. Unlike Optix, DXR and Vulkan RayTracing are designed for real-time rendering pipelines. They can share resources between raytracing and rasterization pipelines, which has advantages in hybrid rendering.</p>
<p>Compared to traditional rasterization-based rendering, raytracing is more direct and can generate a more realistic image.</p>
<p>todo@todo@</p>
<h1 id="RayTracing-Acceleration-Structure"><a href="#RayTracing-Acceleration-Structure" class="headerlink" title="RayTracing Acceleration Structure"></a>RayTracing Acceleration Structure</h1><p>“A Brief Introduction” part provides a brief introduction to acceleration structure, such as constructing acceleration structure, ray intersection and ray transversal. “Implementation Details” part dicribes the implementation details of building the acceleration structure in CryEngine. “Extended” part discusses low-level  possible hardware implementations, such as BVH construction schemes (LBVH, Binding SAH,etc) and ray transversal optimization and methods.</p>
<h2 id="A-Brief-Introduction"><a href="#A-Brief-Introduction" class="headerlink" title="A Brief Introduction"></a>A Brief Introduction</h2><h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><p>Both DXR and Vulkan RayTracing use bounding volume hierarchies (BVH) for acceleration, which is also commonly used for offline ray tracing. BVH is an object partition data structure. It has more advantages than space partition (BSP-Tree,Octree,etc). One advantage of BVH is that the scene can be rebuilt easily for dynamic objects: just recompute the leaf node based on the current geometry. Additionally, the two-level acceleration structure employed in the current raytracing API can optimize rigid body animation further: only update the transform matrix without the expensive bottom-level acceleration structure update. Another advantage of BVH is that the maximum size used is known, as the number of leaves is limited.</p>
<h3 id="Two-Level-Acceleration-Structure"><a href="#Two-Level-Acceleration-Structure" class="headerlink" title="Two-Level Acceleration Structure"></a>Two-Level Acceleration Structure</h3><p>Vulkan employs a two-level acceleration structure to accelerate scene transversal and ray intersections. The bottom-level acceleration structure (BLAS) contains a set of geometries. In the Vulkan API, we can set two types of geometries: <strong>triangles or procedural</strong>. The former type contains a set of triangles, that is to say, real vertex data and index data. Additionally, the BLAS with triangle geometry type contains AABB to encapsulate the geometry after it has been built. For the later geometry type, we should specify AABBs and the associated intersection function such as the ray-sphere test function. In practice, we <strong>prefer using triangle geometry</strong>, since both triangles and AABBs are hardware accelerated, but the procedural type involves additional user defined intersection functions in a shader, which is slower.</p>
<p><strong>[IMAGE]</strong></p>
<p>The top-level acceleration structure (TLAS) consists of instances that reference the BLAS. And each instance contains a transform. We can only update the instance transform of TLAS for rigid-body animation.</p>
<h3 id="The-Trade-Offs-of-Structure-Building"><a href="#The-Trade-Offs-of-Structure-Building" class="headerlink" title="The Trade-Offs of Structure Building"></a>The Trade-Offs of Structure Building</h3><p>The driver is responsible for scheduling construction tasks after requesting the acceleration structure building. And the highly parallel work (calculate AABB, sorte) can accelerated by GPU. In addition, <strong>AS management (build&#x2F;updata) can be moved to an async compute queue</strong>, which could completely hide the cost in many cases. AS management is essentialy software-based work, which allows the driver to optimize its construction algorithm continuously.</p>
<p>Vulkan exposed three build options to AS management:<br>For the PREFER_FAST_TRACE bit, the driver should choose the algorithm with better runtime transversal efficiency.<br>For the PREFER_FAST_BUILD bit, the driver should choose the algorithm with a faster construction rate.<br>For the default option, driver should choose a compromise solution with a balance between trace and build speed.<br>Generally, we <strong>employ PREFER_FAST_BUILD for BLAS, as well as PREFER_FAST_TRACE for TLAS</strong>.<br>In the later extend part, we will discuss three algorithms corresponding to PREFER_FAST_TRACE, PREFER_FAST_BUILD and default option.</p>
<p>Ray tracing has more geometries in GPU memory than traditional rasterization methods. Vulkan has provided additional options for compacting the acceleration structure. Generally, we only compact BLAS, since it has more geometry data than TLAS</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h3 id="deffered"><a href="#deffered" class="headerlink" title="deffered"></a>deffered</h3><h3 id="Ray-Transversal-And-Intersection"><a href="#Ray-Transversal-And-Intersection" class="headerlink" title="Ray Transversal And Intersection"></a>Ray Transversal And Intersection</h3><h2 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h2><h3 id="Vertex-Index-Buffer-Creation"><a href="#Vertex-Index-Buffer-Creation" class="headerlink" title="Vertex&#x2F;Index Buffer Creation"></a>Vertex&#x2F;Index Buffer Creation</h3><p>At first, declare the object geometry structure, it consists of the following members:<br>1.ObjVertexBuffer&#x2F;ObjIndexBuffer: the vertex data loaded from disk.<br>2.buffer_handle_t: the GPU vertex buffer handle.<br>3.CDeviceInputStream: the vertex&#x2F;index streaming information, contains buffer handle, stride and bind slot.<br>4.Vertex&#x2F;Index bindless index: store the index to the bindless descriptor set.<br>5.Array of SRayTracingInstanceTransform: holds all transform information for this geometry.<br>6.CRayTracingBottomLevelAccelerationStructurePtr: the pointer to the bottom level acceleration structure.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SObjectGeometry</span></span><br><span class="line">&#123;</span><br><span class="line">	ObjVertexBuffer m_objectVB;</span><br><span class="line">	ObjIndexBuffer m_objectIB;</span><br><span class="line"></span><br><span class="line">	<span class="type">buffer_handle_t</span> m_pObjectVB;</span><br><span class="line">	<span class="type">buffer_handle_t</span> m_pObjectIB;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> CDeviceInputStream* m_pObjectVertexInputSet = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="type">const</span> CDeviceInputStream* m_pObjectIndexInputSet = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	uint32 m_vbBindlessIndex = <span class="number">0</span>;</span><br><span class="line">	uint32 m_ibBindlessIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;SRayTracingInstanceTransform&gt; m_rayTracingTransforms;</span><br><span class="line">	CRayTracingBottomLevelAccelerationStructurePtr m_pRtBottomLevelAS;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SObjectGeometry</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Then, create the data and fill it into the SObjectGeometry. Create the vertex data by custom mesh generate function or load from disk. Once the prepared data is ready, we need to upload it to the GPU and obtain the vertex buffer handle.</p>
<p>CryEngine employs SPoolManager to manage the vertex buffer and index buffer. SPoolManager creates buffer pools upon initialization, such as static vertex buffer pool, dynamic index buffer pool, and transient buffer pool. As an example, the static vertex buffer pool is declared as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> CBufferPoolImpl&lt;</span><br><span class="line">    CDeviceObjectFactory::BIND_VERTEX_BUFFER</span><br><span class="line">    , CDeviceObjectFactory::USAGE_DIRECT_ACCESS_CPU_COHERENT</span><br><span class="line">    , CDynamicDefragAllocator</span><br><span class="line">    &gt; SStaticBufferPoolVB;</span><br></pre></td></tr></table></figure>
<p>The first template parameter is binding flags (bind vertex, bind index, etc), and the second parameter is usage flags (SRV, UAV, etc).</p>
<p>In order to properly use the static vertex buffer in bindless ray tracing, we must add the extra buffer flag when CBufferPool calls CreateBank:<br>VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR<br>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT<br>The former flag is used in acceleration structure, the later in bindless ray tracing.</p>
<h3 id="Acceleration-structure-construction"><a href="#Acceleration-structure-construction" class="headerlink" title="Acceleration structure construction"></a>Acceleration structure construction</h3><p>BLAS and TLAS have common foundation parameters:</p>
<p>1.Build Flag: As mentioned in the above “The Trade-Offs of Structure Building” part, the drivers should implement at least three AS manager methods: prefer trace, prefer build and balance.<br>They correspond to VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR and VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV in Vulkan raytracing.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmask specifying additional parameters for acceleration structure builds</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EBuildAccelerationStructureFlag</span> : uint32</span><br><span class="line">&#123;</span><br><span class="line">	eBuild_None = <span class="number">0</span>,</span><br><span class="line">	eBuild_PreferTrace = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	eBuild_PreferBuild = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">DEFINE_ENUM_FLAG_OPERATORS</span>(EBuildAccelerationStructureFlag);</span><br></pre></td></tr></table></figure>
<p>eBuild_PreferTrace indicates that the given acceleration structure build should prioritize trace performance over build time, and eBuild_PreferBuild indicates that the given acceleration structure build should prioritize build time over trace performance.</p>
<p>2.Structure Size: The size required in the acceleration structure for build or update operation.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SRayTracingAccelerationStructSize</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	uint64 m_nAccelerationStructureSize = <span class="number">0</span>;</span><br><span class="line">	uint64 m_nUpdateScratchSize = <span class="number">0</span>;</span><br><span class="line">	uint64 m_nBuildScratchSize = <span class="number">0</span>;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>m_nAccelerationStructureSize indicates the size in bytes required in a AccelerationStructure for a build or update operation, m_nUpdateScratchSize indicates the size in bytes required in a scratch buffer for an update operation, and m_nBuildScratchSize indicates the size in bytes required in a scratch buffer for a build operation.</p>
<h4 id="Bottom-level-acceleration-structure-construction"><a href="#Bottom-level-acceleration-structure-construction" class="headerlink" title="Bottom-level acceleration structure construction"></a>Bottom-level acceleration structure construction</h4><p>Bottom-level acceleration structure construction is divided into three steps: construct the create information, create the acceleration structure and build the acceleration structure.</p>
<h5 id="Construct-the-create-information"><a href="#Construct-the-create-information" class="headerlink" title="Construct the create information"></a>Construct the create information</h5><p>The bottom-level create information requires two parts:<br>1.Triangle information, including vertex data (specifying the vertex buffer, format, number, etc) , vertex range data (specifying the primitive offset, first vertex index, etc)<br>2.Index information.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SRayTracingGeometryTriangle</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">STriangleVertexInfo</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> CDeviceInputStream* m_sVertexStreaming;</span><br><span class="line">		InputLayoutHandle m_hVertexPositionFormat = EDefaultInputLayouts::P3F;		<span class="comment">// The VkFormat of each vertex element</span></span><br><span class="line">		uint32 m_nMaxVertex = <span class="number">0</span>;											<span class="comment">// The highest index of a vertex that will be addressed by a build command using this structure.</span></span><br><span class="line">	&#125;m_sTriangVertexleInfo;													<span class="comment">// Triangle info: Structure specifying a triangle geometry in a bottom-level acceleration structure</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SRangeInfo</span></span><br><span class="line">	&#123;</span><br><span class="line">		uint32 m_nPrimitiveCount = <span class="number">0</span>;										<span class="comment">// The number of primitives for a corresponding acceleration structure geometry</span></span><br><span class="line">		uint32 m_nPrimitiveOffset = <span class="number">0</span>;										<span class="comment">// An offset in bytes into the memory where primitive data is defined.</span></span><br><span class="line">		uint32 m_nFirstVertex = <span class="number">0</span>;											<span class="comment">// The index of the first vertex to build from for triangle geometry</span></span><br><span class="line">	&#125;m_sRangeInfo;															<span class="comment">// Range info: structure specifying build offsets and counts for acceleration structure builds</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> bForceOpaque = <span class="literal">true</span>;											<span class="comment">// Set this to false turns off any-hit shader</span></span><br><span class="line">	<span class="type">bool</span> bEnable = <span class="literal">true</span>;												<span class="comment">// Whether this geometry triangle will be enabled</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Create a bottom-level acceleration structure for each object geometry.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint32 index = <span class="number">0</span>; index &lt; m_nObjectNum; index++)</span><br><span class="line">&#123;</span><br><span class="line">	SRayTracingBottomLevelASCreateInfo rtBottomLevelCreateInfo;</span><br><span class="line">	rtBottomLevelCreateInfo.m_eBuildFlag = EBuildAccelerationStructureFlag::eBuild_PreferBuild;</span><br><span class="line">	rtBottomLevelCreateInfo.m_sSTriangleIndexInfo.m_sIndexStreaming = m_objectGeometry[index]-&gt;m_pObjectIndexInputSet;</span><br><span class="line">	rtBottomLevelCreateInfo.m_sSTriangleIndexInfo.m_nIndexBufferOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	SRayTracingGeometryTriangle rtGeometryTriangle;</span><br><span class="line">	rtGeometryTriangle.m_sTriangVertexleInfo.m_sVertexStreaming = m_objectGeometry[index]-&gt;m_pObjectVertexInputSet;</span><br><span class="line">	rtGeometryTriangle.m_sTriangVertexleInfo.m_nMaxVertex = m_objectGeometry[index]-&gt;m_objectVB.<span class="built_in">size</span>();</span><br><span class="line">	rtGeometryTriangle.m_sTriangVertexleInfo.m_hVertexPositionFormat = EDefaultInputLayouts::P3F;</span><br><span class="line">	rtGeometryTriangle.m_sRangeInfo.m_nFirstVertex = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CRY_ASSERT</span>(m_objectGeometry[index]-&gt;m_objectIB.<span class="built_in">size</span>() % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">	rtGeometryTriangle.m_sRangeInfo.m_nPrimitiveCount = m_objectGeometry[index]-&gt;m_objectIB.<span class="built_in">size</span>() / <span class="number">3</span>;</span><br><span class="line">	rtGeometryTriangle.m_sRangeInfo.m_nPrimitiveOffset = <span class="number">0</span>;</span><br><span class="line">	rtGeometryTriangle.bEnable = <span class="literal">true</span>;</span><br><span class="line">	rtGeometryTriangle.bForceOpaque = <span class="literal">true</span>;</span><br><span class="line">	rtBottomLevelCreateInfo.m_rtGeometryTriangles.<span class="built_in">push_back</span>(rtGeometryTriangle);</span><br><span class="line"></span><br><span class="line">	m_objectGeometry[index]-&gt;m_pRtBottomLevelAS = <span class="built_in">GetDeviceObjectFactory</span>().<span class="built_in">CreateRayTracingBottomLevelAS</span>(rtBottomLevelCreateInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Create-the-acceleration-structure"><a href="#Create-the-acceleration-structure" class="headerlink" title="Create the acceleration structure"></a>Create the acceleration structure</h5><p>In order to create an acceleration structure, we must obtain the size information of the acceleration structure by calling vkGetAccelerationStructureBuildSizesKHR, and then create the acceleration structure buffer with the calculated size. Next, call vkCreateAccelerationStructureKHR with the structure creation information, and store the result in accelerationStructureHandle. It is also necessary to obtain the device address of accelerationStructureHandle. This parameter is required in the next TLAS construction. </p>
<p>It should be noted that a new flag (USAGE_ACCELERATION_STRUCTURE) should be added to the creation of the acceleration structure buffer. It corresponds to XXX_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR in my implementation, which indicates this buffer is suitable for use as a read-only input to an acceleration structure build.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m_sSizeInfo = <span class="built_in">GetDeviceObjectFactory</span>().<span class="built_in">GetRayTracingBottomLevelASSize</span>(rtBottomLevelCreateInfo);</span><br><span class="line"></span><br><span class="line">m_accelerationStructureBuffer.<span class="built_in">Create</span>(<span class="number">1u</span>, <span class="built_in">static_cast</span>&lt;uint32&gt;(m_sSizeInfo.m_nAccelerationStructureSize), DXGI_FORMAT_UNKNOWN, CDeviceObjectFactory::USAGE_ACCELERATION_STRUCTURE, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">VkAccelerationStructureCreateInfoKHR accelerationStructureCreateInfo = &#123; VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR &#125;;</span><br><span class="line">accelerationStructureCreateInfo.buffer = m_accelerationStructureBuffer.<span class="built_in">GetDevBuffer</span>()-&gt;<span class="built_in">GetBuffer</span>()-&gt;<span class="built_in">GetHandle</span>();</span><br><span class="line">accelerationStructureCreateInfo.offset = <span class="number">0</span>;</span><br><span class="line">accelerationStructureCreateInfo.size = m_sSizeInfo.m_nAccelerationStructureSize;</span><br><span class="line">accelerationStructureCreateInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;</span><br><span class="line"></span><br><span class="line">Extensions::KHR_acceleration_structure::<span class="built_in">vkCreateAccelerationStructureKHR</span>(m_pDevice-&gt;<span class="built_in">GetVkDevice</span>(), &amp;accelerationStructureCreateInfo, <span class="literal">nullptr</span>, &amp;accelerationStructureHandle);</span><br><span class="line"></span><br><span class="line">VkAccelerationStructureDeviceAddressInfoKHR deviceAddressInfo = &#123; VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR &#125;;</span><br><span class="line">deviceAddressInfo.accelerationStructure = accelerationStructureHandle;</span><br><span class="line">accelerationStructureDeviceAddress = Extensions::KHR_acceleration_structure::<span class="built_in">vkGetAccelerationStructureDeviceAddressKHR</span>(m_pDevice-&gt;<span class="built_in">GetVkDevice</span>(), &amp;deviceAddressInfo);</span><br></pre></td></tr></table></figure>

<p>One of the advantages of BVH over space partitioning is that the structure size is known. Once the required data (vertex&#x2F;index buffer, format, stride, etc) is ready, we can query the size of bottom-level acceleration structure information. The shape and type of the acceleration structure to be created is described in the VkAccelerationStructureBuildGeometryInfoKHR structure. This is the same structure that will later be used for the actual build, but the acceleration structure parameters and geometry data pointers <strong>do not need to be fully populated</strong> at this point (although they can be), just the acceleration structure type, and the geometry types, counts, and maximum sizes. These sizes are <strong>valid for any sufficiently similar acceleration structure</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetBottomLevelAccelerationStructureBuildInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> VkDevice* pVkDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> std::vector&lt;SRayTracingGeometryTriangle&gt;&amp; rtGeometryTriangles,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> SRayTracingBottomLevelASCreateInfo::STriangleIndexInfo&amp; sSTriangleIndexInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	EBuildAccelerationStructureFlag eBuildFlag,</span></span></span><br><span class="line"><span class="params"><span class="function">	EBuildAccelerationStructureMode eBuildMode,</span></span></span><br><span class="line"><span class="params"><span class="function">	SVulkanRayTracingBLASBuildInfo&amp; outvkRtBLASBuildInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;uint32&gt; maxPrimitiveCounts;</span><br><span class="line">	<span class="keyword">for</span> (uint32 index = <span class="number">0</span>; index &lt; rtGeometryTriangles.<span class="built_in">size</span>(); index++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> SRayTracingGeometryTriangle&amp; rayTracingGeometryTriangle = rtGeometryTriangles[index];</span><br><span class="line">		VkDeviceAddress vertexDeviceAddress = <span class="built_in">InputStreamGetBufferDeviceAddress</span>(xxxxxx);</span><br><span class="line"></span><br><span class="line">		VkAccelerationStructureGeometryKHR accelerationStructureGeometry = &#123; VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR &#125;;</span><br><span class="line">		......</span><br><span class="line">		accelerationStructureGeometry.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;</span><br><span class="line">		accelerationStructureGeometry.geometry.triangles = xxx;</span><br><span class="line">		outvkRtBLASBuildInfo.m_vkRtGeometryTrianglesInfo.<span class="built_in">push_back</span>(accelerationStructureGeometry);</span><br><span class="line"></span><br><span class="line">		VkAccelerationStructureBuildRangeInfoKHR RangeInfo = &#123;&#125;;</span><br><span class="line">		outvkRtBLASBuildInfo.m_vkAsBuildRangeInfo.<span class="built_in">push_back</span>(RangeInfo);</span><br><span class="line"></span><br><span class="line">		maxPrimitiveCounts.<span class="built_in">push_back</span>(rayTracingGeometryTriangle.m_sTriangVertexleInfo.m_nMaxVertex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outvkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;</span><br><span class="line">	......</span><br><span class="line">	outvkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.pGeometries = outvkRtBLASBuildInfo.m_vkRtGeometryTrianglesInfo.<span class="built_in">data</span>();</span><br><span class="line">	Extensions::KHR_acceleration_structure::<span class="built_in">vkGetAccelerationStructureBuildSizesKHR</span>(*pVkDevice, VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR, &amp;outvkRtBLASBuildInfo.m_vkAsBuildGeometryInfo, maxPrimitiveCounts.<span class="built_in">data</span>(), &amp;outvkRtBLASBuildInfo.m_vkAsBuildSizeInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetBottomLevelAccelerationStructureBuildInfo is a shared function between creating and building BLAS, which is the same as VkAccelerationStructureBuildGeometryInfoKHR. From this function, we can obtain the size for Create BLAS and the build information for Build BLAS.</p>
<h5 id="Build-the-acceleration-structure"><a href="#Build-the-acceleration-structure" class="headerlink" title="Build the acceleration structure"></a>Build the acceleration structure</h5><p>We construct the acceleration structure <strong>in batch</strong> mode by gathering all of the BLAS of each geometry and composing them into an array.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;CRayTracingBottomLevelAccelerationStructurePtr&gt; rtBottomLevelASPtrs;</span><br><span class="line"><span class="keyword">for</span> (uint32 index = <span class="number">0</span>; index &lt; m_nObjectNum; index++)</span><br><span class="line">&#123;</span><br><span class="line">	rtBottomLevelASPtrs.<span class="built_in">push_back</span>(m_objectGeometry[index]-&gt;m_pRtBottomLevelAS);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">pCommandInterface-&gt;<span class="built_in">BuildRayTracingBottomLevelASs</span>(rtBottomLevelASPtrs);</span><br></pre></td></tr></table></figure>

<p>In acceleration structure building, scratch buffers are required, but they are not used in ray tracing because acceleration structure buffers require more information, such as AABBs. These extra data are generated in VKCMDBuildAccelerationStructuresKHR. Therefore, <strong>the scratch buffer keeps temporary data</strong>, which can be released after building.Each BLAS in a batch can share a single scratch buffer, whose size is the total size of all the BLAS.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64 nTotalScratchBufferSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; blas : rtBottomLevelASPtrs)</span><br><span class="line">&#123;</span><br><span class="line">	nTotalScratchBufferSize += blas-&gt;m_sSizeInfo.m_nBuildScratchSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGpuBuffer scratchBuffer;</span><br><span class="line">scratchBuffer.<span class="built_in">Create</span>(<span class="number">1u</span>, <span class="built_in">static_cast</span>&lt;uint32&gt;(nTotalScratchBufferSize), DXGI_FORMAT_UNKNOWN, CDeviceObjectFactory::USAGE_STRUCTURED | CDeviceObjectFactory::BIND_UNORDERED_ACCESS, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>Lastly, obtain the acceleration structure building geometry information, specify the scratch buffer device address, and build the acceleration structure in batches.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;SVulkanRayTracingBLASBuildInfo&gt; tempBuildInfos;</span><br><span class="line">std::vector&lt;VkAccelerationStructureBuildGeometryInfoKHR&gt; buildGeometryInfos;</span><br><span class="line">std::vector&lt;VkAccelerationStructureBuildRangeInfoKHR*&gt; buildRangeInfos;</span><br><span class="line"></span><br><span class="line">uint64 nScratchBufferOffset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; blas : rtBottomLevelASPtrs)</span><br><span class="line">&#123;</span><br><span class="line">	tempBuildInfos.<span class="built_in">push_back</span>(<span class="built_in">SVulkanRayTracingBLASBuildInfo</span>());</span><br><span class="line">	SVulkanRayTracingBLASBuildInfo&amp; vkRtBLASBuildInfo = tempBuildInfos[tempBuildInfos.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetBottomLevelAccelerationStructureBuildInfo</span>(xxxxxx, vkRtBLASBuildInfo);</span><br><span class="line"></span><br><span class="line">	VkBufferDeviceAddressInfo bufferDeviceAddressInfo = &#123; VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO &#125;;</span><br><span class="line">	bufferDeviceAddressInfo.buffer = scratchBuffer.<span class="built_in">GetDevBuffer</span>()-&gt;<span class="built_in">GetBuffer</span>()-&gt;<span class="built_in">GetHandle</span>();</span><br><span class="line">	VkDeviceAddress scratchBufferAddress = <span class="built_in">vkGetBufferDeviceAddress</span>(<span class="built_in">GetDevice</span>()-&gt;<span class="built_in">GetVkDevice</span>(), &amp;bufferDeviceAddressInfo) + nScratchBufferOffset;</span><br><span class="line">	nScratchBufferOffset += blas-&gt;m_sSizeInfo.m_nBuildScratchSize;</span><br><span class="line"></span><br><span class="line">	CVulkanRayTracingBottomLevelAccelerationStructure* vkRtBLAS = <span class="built_in">static_cast</span>&lt;CVulkanRayTracingBottomLevelAccelerationStructure*&gt;(blas.<span class="built_in">get</span>());</span><br><span class="line">	vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.dstAccelerationStructure = vkRtBLAS-&gt;accelerationStructureHandle;</span><br><span class="line">	vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.srcAccelerationStructure = <span class="literal">nullptr</span>;</span><br><span class="line">	vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.scratchData.deviceAddress = scratchBufferAddress;</span><br><span class="line"></span><br><span class="line">	buildGeometryInfos.<span class="built_in">push_back</span>(vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo);</span><br><span class="line">	buildRangeInfos.<span class="built_in">push_back</span>(vkRtBLASBuildInfo.m_vkAsBuildRangeInfo.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VkCommandBuffer cmdBuffer = <span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">GetVkCommandList</span>();</span><br><span class="line">Extensions::KHR_acceleration_structure::<span class="built_in">vkCmdBuildAccelerationStructuresKHR</span>(cmdBuffer, rtBottomLevelASPtrs.<span class="built_in">size</span>(), buildGeometryInfos.<span class="built_in">data</span>(), buildRangeInfos.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>


<h2 id="Extended"><a href="#Extended" class="headerlink" title="Extended"></a>Extended</h2><h3 id="BVH-example"><a href="#BVH-example" class="headerlink" title="BVH example"></a>BVH example</h3><h3 id="Scene-Cohenrency"><a href="#Scene-Cohenrency" class="headerlink" title="Scene Cohenrency"></a>Scene Cohenrency</h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/01/cesvsm/" rel="prev" title="GPU-Driven Virtual Shadow Map In CryEngine">
                  <i class="fa fa-angle-left"></i> GPU-Driven Virtual Shadow Map In CryEngine
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/02/cerrtb/" rel="next" title="CryEngine Baking:Real Time RayTracing Baker">
                  CryEngine Baking:Real Time RayTracing Baker <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
