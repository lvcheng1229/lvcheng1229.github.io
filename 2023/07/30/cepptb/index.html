<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lvcheng1229.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The complexity of postprocess effects varies depending on the screen tile they are applied to. For example, we can only take one sample(disable blur) for pixels whose velocity is relatively low using">
<meta property="og:type" content="article">
<meta property="og:title" content="CryEngine PostProcess:Tiled Based Bloom Using Indirect Compute">
<meta property="og:url" content="https://lvcheng1229.github.io/2023/07/30/cepptb/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="The complexity of postprocess effects varies depending on the screen tile they are applied to. For example, we can only take one sample(disable blur) for pixels whose velocity is relatively low using">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/flowinfo2.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer2.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer3.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer4.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/vulkanresult.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/20230812213557.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/20230812213642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/bloomresultj.jpg">
<meta property="article:published_time" content="2023-07-30T15:08:25.000Z">
<meta property="article:modified_time" content="2023-08-12T15:01:54.944Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/flowinfo2.jpg">


<link rel="canonical" href="https://lvcheng1229.github.io/2023/07/30/cepptb/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://lvcheng1229.github.io/2023/07/30/cepptb/","path":"2023/07/30/cepptb/","title":"CryEngine PostProcess:Tiled Based Bloom Using Indirect Compute"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CryEngine PostProcess:Tiled Based Bloom Using Indirect Compute | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Source-Code"><span class="nav-number">1.</span> <span class="nav-text">Source Code</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lvcheng1229.github.io/2023/07/30/cepptb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CryEngine PostProcess:Tiled Based Bloom Using Indirect Compute | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CryEngine PostProcess:Tiled Based Bloom Using Indirect Compute
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-30 23:08:25" itemprop="dateCreated datePublished" datetime="2023-07-30T23:08:25+08:00">2023-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-12 23:01:54" itemprop="dateModified" datetime="2023-08-12T23:01:54+08:00">2023-08-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>The complexity of postprocess effects varies depending on the screen tile they are applied to. For example, we can only take one sample(disable blur) for pixels whose velocity is relatively low using branching. However, dynamic branching on the GPU is costly since we cannot ensure that multiple threads donâ€™t cause divergence.</p>
<p>The probability of divergence will be significantly reduced if different shaders can be executed on different screen tiles. Therefore, the problem is how to dispatch different shaders on various tiles. </p>
<p>Indirect-Compute Shader is an answer: In the first step, dispatch a compute shader to classify the tiles and determine the tile count and index for each shader complexity level. Then, dispatch a variety of indirect-compute shaders for each tile with the arguments generated in the last step.The result is that each tile performs a specific version of the shader and eliminates divergence.</p>
<p>This article will take the bloom pass as an example of implementing the tile-based post process.</p>
<p>The bloom algorithm is based on the implementation of CryEngine in this demo. So, we are going to discuss the implementation of CryEngine first. There are three parts to CryEngineâ€™s bloom algorithm. The first part is downsampling. CryEngine takes two passes to downsample the render target. The output of the downsample is a quarter-resolution render target relative to the original RT. Then, CryEngine performs a Gaussian blur with a quarter-resolution render target. In this step, CE takes four passes to blur the source texture: two for vertical and two for horizontal. Each pass samples the texture 16 times, so the total number of samples is 64 * Resolution! Finally, CE performs a lerp between scene color and bloom results as the result in the tone mapping pass.</p>
<p>What we are going to do is optimize its sample count. Here is the flow graph of tiled-based bloom algorithm:</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/flowinfo2.jpg"></p>
<p><strong>Step1.Mask screen tiles contain pixels whose luminance exceeds the threshold.</strong></p>
<p>Each tile corresponds to a dispatch group with 8x8 threads and contains 8x8 pixels. We use a group shared unit array to record group luminance info. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupshared uint MaskInfo[GROUP_SIZE_X*GROUP_SIZE_Y*<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Luminance &gt; BloomThreshlod)</span><br><span class="line">&#123;</span><br><span class="line">	Result.rgb = BloomOUT.rgb;</span><br><span class="line">	MaskInfo[GroupThreadID.y * GROUP_SIZE_X + GroupThreadID.x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer2.jpg"></p>
<p>Then, perform parallel reduction within each thread block to determine if this tile contains at least one pixel that exceeds the threshold. As a result, we will get a mask buffer with the size of one eighth of the input bloom texture.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GroupMemoryBarrierWithGroupSync</span>();</span><br><span class="line"></span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span> (uint SetpIndex = <span class="number">1</span>; SetpIndex &lt; <span class="number">4</span>; SetpIndex++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> uint TileSize = <span class="built_in">uint</span>(GROUP_TILE_SIZE) &gt;&gt; SetpIndex;</span><br><span class="line">	<span class="type">const</span> uint ReduceBankSize = TileSize * TileSize;</span><br><span class="line">	[branch]</span><br><span class="line">	<span class="keyword">if</span> (GroupThreadIndex &lt; ReduceBankSize)</span><br><span class="line">	&#123;</span><br><span class="line">		uint RawMask[<span class="number">4</span>];</span><br><span class="line">		[unroll]</span><br><span class="line">		<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			uint LDSIndex = GroupThreadIndex + i * ReduceBankSize;</span><br><span class="line">			RawMask[i] = MaskInfo[LDSIndex];</span><br><span class="line">		&#125;</span><br><span class="line">		uint MaskCombine = RawMask[<span class="number">0</span>] || RawMask[<span class="number">1</span>] || RawMask[<span class="number">2</span>] || RawMask[<span class="number">3</span>];</span><br><span class="line">		MaskInfo[GroupThreadIndex] = MaskCombine;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GroupThreadIndex == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BloomMaskOutUAV[GroupID.y * bloomCB.BufferSize.x + GroupID.x] = MaskInfo[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step2.Record the tile index and calculate the number of tiles that will perform the Gaussian blur.</strong></p>
<p>The results will be used as indirect arguments in the next step.</p>
<p>The kernel size of the first two Gaussian blur passes is 7 and each member of the mask buffer represents 8x8 pixels. Therefore, the tile being masked will affect the 3x3 tiles around it. </p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer3.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint CIndex = DispatchThreadID.y * MaskBufferSize.x + DispatchThreadID.x;</span><br><span class="line">uint LCIndex = CIndex - <span class="number">1</span>;</span><br><span class="line">uint RCIndex = CIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">uint TIndex = (DispatchThreadID.y - <span class="number">1</span>) * MaskBufferSize.x + DispatchThreadID.x;</span><br><span class="line">uint LTIndex = TIndex - <span class="number">1</span>;</span><br><span class="line">uint RTIndex = TIndex + <span class="number">1</span>;</span><br><span class="line">uint BIndex = (DispatchThreadID.y +<span class="number">1</span> ) * MaskBufferSize.x + DispatchThreadID.x;</span><br><span class="line">uint LBIndex = BIndex - <span class="number">1</span>;</span><br><span class="line">uint RBIndex = BIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">uint CValue = IndexGen_MaskBuffer[CIndex].x;</span><br><span class="line">uint LCValue = IndexGen_MaskBuffer[LCIndex].x;</span><br><span class="line">uint RCValue = IndexGen_MaskBuffer[RCIndex].x;</span><br><span class="line">uint TValue = IndexGen_MaskBuffer[TIndex].x;</span><br><span class="line">uint LTValue = IndexGen_MaskBuffer[LTIndex].x;</span><br><span class="line">uint RTValue = IndexGen_MaskBuffer[RTIndex].x;</span><br><span class="line">uint BValue = IndexGen_MaskBuffer[BIndex].x;</span><br><span class="line">uint LBValue = IndexGen_MaskBuffer[LBIndex].x;</span><br><span class="line">uint RBValue = IndexGen_MaskBuffer[RBIndex].x;</span><br><span class="line"></span><br><span class="line">uint CMaskValue = CValue || LCValue || RCValue;</span><br><span class="line">uint TMaskValue = TValue || LTValue || RTValue;</span><br><span class="line">uint BMaskValue = BValue || LBValue || RBValue;</span><br><span class="line">uint MaskValue = CMaskValue || TMaskValue || BMaskValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MaskValue)</span><br><span class="line">&#123;</span><br><span class="line">	uint PreCountOut;</span><br><span class="line">	IndexGen_DispatchIndirectCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>, <span class="built_in">uint</span>(<span class="number">1</span>), PreCountOut);</span><br><span class="line">	<span class="type">const</span> uint TileIndex = (DispatchThreadID.x &amp; <span class="number">0xFFFF</span>) | ((DispatchThreadID.y &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">	IndexGen_TileIndexUAV[PreCountOut] = TileIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We use the InterlockedAdd function to count the tile number and store the result in an RWByteAddressBuffer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RWByteAddressBuffer 			IndexGen_DispatchIndirectCount	: <span class="built_in">register</span>(u1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">all</span>(DispatchThreadID == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	IndexGen_DispatchIndirectCount.<span class="built_in">Store3</span>(<span class="number">0</span>,<span class="built_in">uint3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MaskValue)</span><br><span class="line">&#123;</span><br><span class="line">	uint PreCountOut;</span><br><span class="line">	IndexGen_DispatchIndirectCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>, <span class="built_in">uint</span>(<span class="number">1</span>), PreCountOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Taking the above figure as an example, the value of the DispatchIndirectCount buffer is (12,1,1) and the value of the tile index buffer is (4,2), (4,3), (4,4), â€¦â€¦, (5,2), (5,3), (5,4),â€¦â€¦</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/maskbuffer4.jpg"></p>
<p>The red blocks are the tiles that performed Gaussian blur in the first two passes, and their size is 8x8 pixels per tile. Next, we will generate the mask buffer for the last two Gaussian blur passes based on the above results. In the last two blur passes, the tile size is 16x16 since the kernel size in the last two blur passes is 15.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span>(MaskValue)</span><br><span class="line">		&#123;</span><br><span class="line">			uint PreCountOut;</span><br><span class="line">			IndexGen_DispatchIndirectCount.<span class="built_in">InterlockedAdd</span>(<span class="number">0</span>, <span class="built_in">uint</span>(<span class="number">1</span>), PreCountOut);</span><br><span class="line">			<span class="type">const</span> uint TileIndex = (DispatchThreadID.x &amp; <span class="number">0xFFFF</span>) | ((DispatchThreadID.y &amp; <span class="number">0xFFFF</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">			IndexGen_TileIndexUAV[PreCountOut] = TileIndex;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> %_RT_SAMPLE0</span></span><br><span class="line">			IndexGen_TileMask[GroupThreadID.y * GROUP_SIZE_X + GroupThreadID.x] = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> %_RT_SAMPLE0</span></span><br><span class="line">		<span class="keyword">if</span>(GroupThreadIndex % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			uint RawMask[<span class="number">4</span>];</span><br><span class="line">			[unroll]</span><br><span class="line">			<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				uint LDSIndex = GroupThreadIndex + i;</span><br><span class="line">				RawMask[i] = IndexGen_TileMask[LDSIndex];</span><br><span class="line">			&#125;</span><br><span class="line">			uint MaskCombine = RawMask[<span class="number">0</span>] || RawMask[<span class="number">1</span>] || RawMask[<span class="number">2</span>] || RawMask[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">			IndexGen_MaskOutputUAV[(DispatchThreadID.y / <span class="number">2</span>) * (MaskBufferSize.x / <span class="number">2</span>) + DispatchThreadID.x / <span class="number">2</span>] = MaskCombine;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Repeat step 2. We will get all the parameters needed in the Gaussian blur pass.</p>
<p><strong>Step3. Dispatch indirect compute shader and perform Gaussian blur.</strong></p>
<p>The dispatch size is (12,1,1) in this example.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetDispatchIndirectArgs</span>(&amp;m_dispatchIndirectCount[IndexPass], <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Get the index for those tiles performing Gaussian blur indexed by GroupID from the tile index buffer and calculate the global UV coordinates based on the tile index.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint TileIndex = BloomFinal_TileInfoUAV.<span class="built_in">Load</span>(GroupID.x).x;</span><br><span class="line">uint2 TileIndexXY = <span class="built_in">uint2</span>(TileIndex &amp; <span class="number">0xFFFF</span>,(TileIndex &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">uint2 UVCoord = TileIndexXY * <span class="built_in">uint2</span>(GROUP_SIZE_X * <span class="number">2</span>,GROUP_SIZE_Y * <span class="number">2</span>) + <span class="built_in">uint2</span>(GroupThreadIndex % (GROUP_SIZE_Y * <span class="number">2</span>), GroupThreadIndex / (GROUP_SIZE_X * <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>Finally, blur the input texture. Here is the code copied from CryEngineâ€™s Gaussian blur implementation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> weights[<span class="number">15</span>] = &#123; <span class="number">153</span>, <span class="number">816</span>, <span class="number">3060</span>, <span class="number">8568</span>, <span class="number">18564</span>, <span class="number">31824</span>, <span class="number">43758</span>, <span class="number">48620</span>, <span class="number">43758</span>, <span class="number">31824</span>, <span class="number">18564</span>, <span class="number">8568</span>, <span class="number">3060</span>, <span class="number">816</span>, <span class="number">153</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> weightSum = <span class="number">262106.0</span>;</span><br><span class="line"></span><br><span class="line">float2 coords = <span class="built_in">float2</span>(UVCoord) * bloomTexSize.zw - bloomParams.xy * <span class="number">7.0</span>;</span><br><span class="line">half3 vColor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	vColor += <span class="built_in">GetTexture2DLod</span>(BloomFinal_Tx2Tx_Source, BloomFinal_Tx2Tx_Sampler, coords,<span class="number">0.0</span>).rgb * (weights[i] / weightSum);</span><br><span class="line">	coords += bloomParams.xy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BloomFinal_OutputUAV[UVCoord] = <span class="built_in">float4</span>(vColor,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>As Cryengine does not support indirect compute shaders, we must expand its renderer to support them.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDeviceComputeCommandInterfaceImpl::DispatchIndirectImpl</span><span class="params">(<span class="type">const</span> CDeviceBuffer* pBuffer, uint32 Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> CDeviceResourceLayout_Vulkan* pVkLayout = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> CDeviceResourceLayout_Vulkan*&gt;(m_computeState.pResourceLayout.cachedValue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ApplyPendingBindings</span>(<span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">GetVkCommandList</span>(), pVkLayout-&gt;<span class="built_in">GetVkPipelineLayout</span>(), VK_PIPELINE_BIND_POINT_COMPUTE, m_computeState.custom.pendingBindings);</span><br><span class="line">	m_computeState.custom.pendingBindings.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">PendingResourceBarriers</span>();</span><br><span class="line">	<span class="built_in">vkCmdDispatchIndirect</span>(<span class="built_in">GetVKCommandList</span>()-&gt;<span class="built_in">GetVkCommandList</span>(), pBuffer-&gt;<span class="built_in">GetBuffer</span>()-&gt;<span class="built_in">GetHandle</span>(), Offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the Vulkan capture result of Renderdoc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/vulkanresult.jpg"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Renderdoc result</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bloom input</td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/20230812213557.png"></td>
</tr>
<tr>
<td align="center">bloom output</td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/20230812213642.png"></td>
</tr>
<tr>
<td align="center">tone mapping output</td>
<td align="center"><img src="https://cdn.jsdelivr.net/gh/lvcheng1229/lvcheng1229.github.io@main/PicGoImg/bloomresultj.jpg"></td>
</tr>
</tbody></table>
<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">textureSize = <span class="built_in">Vec4</span>(<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width), <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height), <span class="number">1.0f</span> / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width), <span class="number">1.0f</span> / <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(height));</span><br><span class="line">maskBufferSize[<span class="number">0</span>] = <span class="built_in">Vec4i</span>(<span class="built_in">divideRoundUp</span>(<span class="built_in">Vec2i</span>(width, height), <span class="built_in">Vec2i</span>(groupSizeX, groupSizeY)), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">maskBufferSize[<span class="number">1</span>] = <span class="built_in">Vec4i</span>(<span class="built_in">divideRoundUp</span>(<span class="built_in">Vec2i</span>(width, height), <span class="built_in">Vec2i</span>(groupSizeX * <span class="number">2</span>, groupSizeY * <span class="number">2</span>)), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function">Vec2i <span class="title">bloomSetupDispatchSize</span><span class="params">(maskBufferSize[<span class="number">0</span>].x, maskBufferSize[<span class="number">0</span>].y)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatchSizeIndexGen[<span class="number">0</span>] = <span class="built_in">divideRoundUp</span>(<span class="built_in">Vec2i</span>(maskBufferSize[<span class="number">0</span>].x, maskBufferSize[<span class="number">0</span>].y), <span class="built_in">Vec2i</span>(groupSizeX, groupSizeY));</span><br><span class="line">dispatchSizeIndexGen[<span class="number">1</span>] = <span class="built_in">divideRoundUp</span>(<span class="built_in">Vec2i</span>(maskBufferSize[<span class="number">1</span>].x, maskBufferSize[<span class="number">1</span>].y), <span class="built_in">Vec2i</span>(groupSizeX, groupSizeY));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bBufferInit)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">InitBuffer</span>();</span><br><span class="line">	bBufferInit = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ColorI nulls = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bAsynchronousCompute = CRenderer::CV_r_D3D12AsynchronousCompute &amp; <span class="built_in">BIT</span>((eStage_BloomSetup - eStage_FIRST_ASYNC_COMPUTE)) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#123;</span><br><span class="line">	m_passBloomSetup.<span class="built_in">SetTechnique</span>(CShaderMan::s_shBloomSetup, <span class="built_in">CCryNameTSCRC</span>(<span class="string">&quot;BloomSetup&quot;</span>), <span class="number">0</span>);</span><br><span class="line">	m_passBloomSetup.<span class="built_in">SetOutputUAV</span>(<span class="number">0</span>, pTiledBloomRT[<span class="number">0</span>]);</span><br><span class="line">	m_passBloomSetup.<span class="built_in">SetOutputUAV</span>(<span class="number">1</span>, &amp;m_tileBloomMaskBuffer[<span class="number">0</span>]);</span><br><span class="line">	m_passBloomSetup.<span class="built_in">SetTextureSamplerPair</span>(<span class="number">0</span>, pSrcRT, EDefaultSamplerStates::LinearClamp);</span><br><span class="line"></span><br><span class="line">	m_parameters-&gt;TexSize = textureSize;</span><br><span class="line">	m_parameters-&gt;BufferSize = maskBufferSize[<span class="number">0</span>];</span><br><span class="line">	m_passBloomSetup.<span class="built_in">SetConstantBuffer</span>(<span class="number">0</span>, m_parameters.<span class="built_in">GetDeviceConstantBuffer</span>());</span><br><span class="line"></span><br><span class="line">	m_passBloomSetup.<span class="built_in">SetDispatchSize</span>(bloomSetupDispatchSize.x, bloomSetupDispatchSize.y, <span class="number">1</span>);</span><br><span class="line">	m_passBloomSetup.<span class="built_in">PrepareResourcesForUse</span>(<span class="built_in">GetDeviceObjectFactory</span>().<span class="built_in">GetCoreCommandList</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">SScopedComputeCommandList <span class="title">computeCommandList</span><span class="params">(bAsynchronousCompute)</span></span>;</span><br><span class="line">	m_passBloomSetup.<span class="built_in">Execute</span>(computeCommandList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int32 Index = <span class="number">0</span>; Index &lt; <span class="number">2</span>; Index++)</span><br><span class="line">&#123;</span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetTechnique</span>(CShaderMan::s_shBloomSetup, <span class="built_in">CCryNameTSCRC</span>(<span class="string">&quot;BloomTileIndexGen&quot;</span>), Index == <span class="number">0</span> ? g_HWSR_MaskBit[HWSR_SAMPLE0] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetOutputUAV</span>(<span class="number">0</span>, &amp;m_tileIndexBuffer[Index]);</span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetOutputUAV</span>(<span class="number">1</span>, &amp;m_dispatchIndirectCount[Index]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Index == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetOutputUAV</span>(<span class="number">2</span>, &amp;m_tileBloomMaskBuffer[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetBuffer</span>(<span class="number">0</span>, &amp;m_tileBloomMaskBuffer[Index]);</span><br><span class="line"></span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">BeginConstantUpdate</span>();</span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetConstant</span>(<span class="built_in">CCryNameR</span>(<span class="string">&quot;MaskBufferSize&quot;</span>), maskBufferSize[Index]);</span><br><span class="line"></span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">SetDispatchSize</span>(dispatchSizeIndexGen[Index].x, dispatchSizeIndexGen[Index].y, <span class="number">1</span>);</span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">PrepareResourcesForUse</span>(<span class="built_in">GetDeviceObjectFactory</span>().<span class="built_in">GetCoreCommandList</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">SScopedComputeCommandList <span class="title">computeCommandList</span><span class="params">(bAsynchronousCompute)</span></span>;</span><br><span class="line">	m_passBloomTileIndexGen[Index]-&gt;<span class="built_in">Execute</span>(computeCommandList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CClearSurfacePass::<span class="built_in">Execute</span>(pTiledBloomRT[<span class="number">1</span>], <span class="built_in">ColorF</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int32 IndexPass = <span class="number">0</span>; IndexPass &lt; <span class="number">2</span>; IndexPass++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> CCryNameTSCRC TechName[<span class="number">2</span>] = &#123; (<span class="string">&quot;BloomFinal&quot;</span>),(<span class="string">&quot;BloomCombine&quot;</span>) &#125;;</span><br><span class="line">	<span class="keyword">for</span> (int32 IndexAxis = <span class="number">0</span>; IndexAxis &lt; <span class="number">2</span>; IndexAxis++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetTechnique</span>(CShaderMan::s_shBloomSetup, TechName[IndexPass], <span class="number">0</span>);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetOutputUAV</span>(<span class="number">0</span>, pTiledBloomRT[<span class="number">1</span> - (IndexAxis + IndexPass * <span class="number">2</span>) % <span class="number">2</span>]);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetOutputUAV</span>(<span class="number">1</span>, &amp;m_tileIndexBuffer[IndexPass]);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetTextureSamplerPair</span>(<span class="number">0</span>, pTiledBloomRT[(IndexAxis + IndexPass * <span class="number">2</span>) % <span class="number">2</span>], EDefaultSamplerStates::LinearClamp);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">BeginConstantUpdate</span>();</span><br><span class="line"></span><br><span class="line">		Vec4 bloomParams;</span><br><span class="line">		<span class="keyword">if</span> (IndexAxis == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bloomParams = <span class="built_in">Vec4</span>(<span class="number">1.0f</span> * textureSize.z * (IndexPass + <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			bloomParams = <span class="built_in">Vec4</span>(<span class="number">0</span>, <span class="number">1.0f</span> * textureSize.w * (IndexPass + <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetConstant</span>(<span class="built_in">CCryNameR</span>(<span class="string">&quot;bloomParams&quot;</span>), bloomParams);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetConstant</span>(<span class="built_in">CCryNameR</span>(<span class="string">&quot;bloomTexSize&quot;</span>), textureSize);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">SetDispatchIndirectArgs</span>(&amp;m_dispatchIndirectCount[IndexPass], <span class="number">0</span>);</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">PrepareResourcesForUse</span>(<span class="built_in">GetDeviceObjectFactory</span>().<span class="built_in">GetCoreCommandList</span>());</span><br><span class="line"></span><br><span class="line">		<span class="function">SScopedComputeCommandList <span class="title">computeCommandList</span><span class="params">(bAsynchronousCompute)</span></span>;</span><br><span class="line">		m_passBloom[IndexPass][IndexAxis]-&gt;<span class="built_in">Execute</span>(computeCommandList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/01/cesvsm/" rel="next" title="CryEngine Shadow:Virtual Shadow Map">
                  CryEngine Shadow:Virtual Shadow Map <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
